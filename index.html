<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>é‰±å±±ã‚²ãƒ¼ãƒ </title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#111820;
    --accent:#59f5c6;
    --accent-2:#ff7bd5;
    --text:#e9f1f7;
    --muted:#9fb3c8;
    --warn:#ffd166;
    --danger:#ff6b6b;

    --cell: min(12.5vw, 64px); /* ã‚¹ãƒãƒ›å„ªå…ˆã‚µã‚¤ã‚º */
    --gap: 6px;
    --radius: 12px;
    --soft: 10px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0; padding:0; background:linear-gradient(180deg,#0b0f14,#0b0f14 60%,#0a0d12); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Helvetica Neue", Arial, "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Emoji", sans-serif;}
  #app{max-width: 480px; margin: 0 auto; padding: 16px 14px 28px;}
  header{
    display:grid; grid-template-columns: 1fr 1fr; grid-auto-rows: auto; gap: 8px;
    position: sticky; top:0; background:linear-gradient(180deg, rgba(11,15,20,.95), rgba(11,15,20,.7) 60%, rgba(11,15,20,0));
    backdrop-filter: blur(6px); padding-bottom: 6px; z-index: 10;
  }
  .card{
    background: linear-gradient(180deg, #0f1621, #0e141d);
    border: 1px solid #1c2633;
    border-radius: var(--radius);
    box-shadow: 0 10px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
  }
  .stat{padding: 10px 12px; display:flex; align-items:center; justify-content: space-between; gap: 10px;}
  .stat b{font-size: 14px; color: var(--muted); font-weight:600;}
  .stat .val{font-size: 18px; font-weight:700; letter-spacing:.2px;}
  .row{display:flex; align-items:center; gap:8px;}
  .pill{
    background: #0b121a;
    border: 1px solid #1b2938;
    border-radius: 999px; padding: 6px 10px; font-size: 12px; color: var(--muted);
  }
  .accent{ color: var(--accent); }
  .accent2{ color: var(--accent-2); }

  /* ã‚°ãƒªãƒƒãƒ‰ */
  #grid{
    margin-top: 10px;
    display: grid;
    grid-template-columns: repeat(6, var(--cell));
    grid-auto-rows: var(--cell);
    gap: var(--gap);
    justify-content: center;
    padding: 12px;
    position: relative;
  }
  .cell{
    width: var(--cell); height: var(--cell);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background: #0d1219;
    border: 1px solid #1a2230;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), inset 0 -10px 18px rgba(0,0,0,.35);
    touch-action: manipulation;
  }
  .cell img{
    width:100%; height:100%; object-fit: cover; display:block; pointer-events:none;
    filter: contrast(1.02) saturate(1.05);
  }
  .cell .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    font-size: 12px; color:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.5);
    background: linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.25));
  }
  .cell .progress{
    position:absolute; left:0; right:0; bottom:0; height:6px; border-radius:6px;
    background: rgba(255,255,255,.06);
  }
  .cell .progress > i{
    display:block; height:100%; width:0%; border-radius:6px;
    background: linear-gradient(90deg, var(--accent), #8afff0);
    box-shadow: 0 0 12px rgba(89,245,198,.5);
  }

  /* ãƒ”ãƒƒã‚±ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
  .fx{
    position:absolute; width: 28px; height: 28px; transform-origin: 60% 90%;
    font-size: 22px; line-height: 28px; text-align:center; pointer-events:none;
    animation: swing .38s ease-in-out forwards;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.6));
  }
  @keyframes swing {
    0% { transform: translate(0,0) rotate(-35deg); opacity: 0; }
    40%{ transform: translate(-6px, -8px) rotate(0deg); opacity: 1; }
    100%{ transform: translate(8px, 10px) rotate(30deg); opacity: .05; }
  }
  .spark{
    position:absolute; font-size: 16px; animation: pop .5s ease-out forwards; pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(255,255,255,.7));
  }
  @keyframes pop{
    0%{ transform: translate(0,0) scale(.7); opacity: 0; }
    30%{ opacity:1; }
    100%{ transform: translate(0,-14px) scale(1.1); opacity:0; }
  }

  /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ */
  #controls{ display:grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
  .panel{ padding: 12px; }
  .buttons{ display:flex; gap:8px; flex-wrap: wrap; }
  button{
    appearance: none; border: 1px solid #1b2938; background: #0b121a; color: var(--text);
    padding: 10px 12px; border-radius: 10px; font-weight: 700; letter-spacing:.2px;
    box-shadow: 0 10px 18px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.03);
  }
  button.primary{
    background: linear-gradient(180deg, #1c2f3f, #132536);
    border-color:#2b4054;
  }
  button:disabled{ opacity:.55; }

  .upg{
    display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
    padding:10px; border-radius:10px; border:1px solid #1b2938; background:#0b121a;
  }
  .upg h4{ margin:0; font-size:14px; }
  .upg small{ color:var(--muted); }
  .upg .lvl{ font-weight:800; color:var(--accent); }
  .upg .cost{ color:var(--warn); font-weight:700; }

  .hint{
    color: var(--muted); font-size: 12px; padding: 4px 2px 0;
  }

  footer{ margin-top: 14px; text-align:center; color: var(--muted); font-size: 11px; }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="card stat">
      <b>ã‚¹ã‚³ã‚¢</b>
      <div class="val" id="scoreVal">0</div>
    </div>
    <div class="card stat">
      <b>æ·±ã•</b>
      <div class="val"><span id="depthVal">0</span> m</div>
    </div>
    <div class="card stat" style="grid-column:1 / -1;">
      <div class="row">
        <b>ãƒ”ãƒƒã‚±ãƒ«</b>
        <span class="pill"><span id="pickVal">50</span>/<span id="pickMax">50</span></span>
        <span class="pill">å›å¾© <span id="regenInfo">1/5s</span></span>
      </div>
      <div class="row">
        <button id="buy1" class="primary">+1ï¼ˆ100ptï¼‰</button>
        <button id="buy10" class="primary">+10ï¼ˆ1000ptï¼‰</button>
      </div>
    </div>
  </header>

  <main class="card panel">
    <div id="grid" aria-label="mine grid"></div>
    
  </main>

  <section id="controls">
    <div class="card panel">
      <h3 style="margin:0 0 8px 0; font-size:16px;">ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰</h3>
      <div class="upg">
        <div>
          <h4>ãƒ”ãƒƒã‚±ãƒ«å›å¾©é€Ÿåº¦ã‚¢ãƒƒãƒ— <span class="lvl">Lv.<span id="uRegenLvl">0</span></span></h4>
          <small>å›å¾©åŠ¹ç‡ +20%/Lvï¼ˆç¾åœ¨: <span id="uRegenRate">1/5s</span>ï¼‰</small>
        </div>
        <button id="uRegenBtn"><span class="cost" id="uRegenCost">500pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>ãƒ”ãƒƒã‚±ãƒ«æœ€å¤§å€‹æ•°ã‚¢ãƒƒãƒ— <span class="lvl">Lv.<span id="uMaxLvl">0</span></span></h4>
          <small>ä¸Šé™ +10/Lvï¼ˆç¾åœ¨: <span id="uMaxNow">50</span>ï¼‰</small>
        </div>
        <button id="uMaxBtn"><span class="cost" id="uMaxCost">500pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>ãƒã‚¤ãƒ³ãƒˆã‚¢ãƒƒãƒ— <span class="lvl">Lv.<span id="uPtsLvl">0</span></span></h4>
          <small>ç²å¾—ãƒã‚¤ãƒ³ãƒˆ +10%/Lvï¼ˆç¾åœ¨å€ç‡: <span id="uPtsNow">1.00Ã—</span>ï¼‰</small>
        </div>
        <button id="uPtsBtn"><span class="cost" id="uPtsCost">800pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>é‰±çªŸæ¡å–å€‹æ•°ã‚¢ãƒƒãƒ— <span class="lvl">Lv.<span id="uCaveLvl">0</span></span></h4>
          <small>é‰±çªŸã®å ±é…¬ +20%/Lv</small>
        </div>
        <button id="uCaveBtn"><span class="cost" id="uCaveCost">800pt</span></button>
      </div>
    </div>
  </section>

  <footer>ç”»åƒ: dirt.png / stone.png / cave.png ã‚’åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ã„ã¦ã­ã€‚</footer>
</div>

<script>
(() => {
  // ====== åŸºæœ¬è¨­å®š ======
  const COLS = 6;
  const ROWS = 7;

  const DIRT = 'dirt';
  const STONE = 'stone';
  const CAVE = 'cave';
  const EMPTY = 'empty';

  const BASE_POINTS = { dirt: 100, stone: 200 };
  const COST_PICK = { dirt: 1, stone: 2 };

  // é‰±çªŸã‚µã‚¤ã‚ºã¨æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
  const CAVE_INFO = {
    1: { secs: 30, baseScore: 300, basePicks: 5 },
    2: { secs: 60, baseScore: 800, basePicks: 12 },
    3: { secs: 120, baseScore: 2000, basePicks: 25 },
  };

  // ãƒ”ãƒƒã‚±ãƒ«å›å¾©ï¼šãƒ™ãƒ¼ã‚¹ã¯ 1æœ¬/5ç§’
  const BASE_REGEN_PER_SEC = 1/5; // 0.2 / sec

  // ====== çŠ¶æ…‹ ======
  let score = 0;
  let depth = 0;

  let pick = 50;
  let pickMax = 50;
  let regenLvl = 0; // +20%/Lv
  let maxLvl = 0;   // +10 cap / Lv
  let ptsLvl = 0;   // +10%/Lv
  let caveLvl = 0;  // +20%/Lv

  let regenAcc = 0; // å›å¾©ã®å°æ•°ç´¯ç©

  // ã‚°ãƒªãƒƒãƒ‰å¯è¦–é ˜åŸŸï¼ˆå…ˆé ­ãŒæœ€ä¸Šæ®µã€æœ«å°¾ãŒæœ€ä¸‹æ®µï¼‰
  let visible = []; // [row][col] -> cell object
  // å…ˆèª­ã¿ã®è¡Œãƒãƒƒãƒ•ã‚¡ï¼ˆæ–°ã—ã„ä¸‹æ®µã‚’è£œå……ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¥ãƒ¼ï¼‰
  let queue = [];

  // é‰±çªŸã‚°ãƒ«ãƒ¼ãƒ—çŠ¶æ…‹
  let caveSeq = 1;
  const caves = new Map(); // id -> {size, state:'idle'|'exploring'|'done', endAt:number, cells:[{r,c}]}

  // ====== å‚ç…§ ======
  const $grid = document.getElementById('grid');
  const $scoreVal = document.getElementById('scoreVal');
  const $depthVal = document.getElementById('depthVal');
  const $pickVal = document.getElementById('pickVal');
  const $pickMax = document.getElementById('pickMax');
  const $regenInfo = document.getElementById('regenInfo');

  const $buy1 = document.getElementById('buy1');
  const $buy10 = document.getElementById('buy10');

  const $uRegenLvl = document.getElementById('uRegenLvl');
  const $uRegenRate = document.getElementById('uRegenRate');
  const $uRegenCost = document.getElementById('uRegenCost');

  const $uMaxLvl = document.getElementById('uMaxLvl');
  const $uMaxNow = document.getElementById('uMaxNow');
  const $uMaxCost = document.getElementById('uMaxCost');

  const $uPtsLvl = document.getElementById('uPtsLvl');
  const $uPtsNow = document.getElementById('uPtsNow');
  const $uPtsCost = document.getElementById('uPtsCost');

  const $uCaveLvl = document.getElementById('uCaveLvl');
  const $uCaveCost = document.getElementById('uCaveCost');

  const $uRegenBtn = document.getElementById('uRegenBtn');
  const $uMaxBtn = document.getElementById('uMaxBtn');
  const $uPtsBtn = document.getElementById('uPtsBtn');
  const $uCaveBtn = document.getElementById('uCaveBtn');

  // ====== ç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
  const rand = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const chance = (p)=> Math.random() < p;

  // æ´çªŸã®äº‹å‰é…ç½®ç”¨ãƒã‚¹ã‚¯ï¼šqueueã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŸºæº–ã§ (rowIdx)->Set of col ã§åŸ‹ã‚ã‚‹ã®ã§ã¯ãªãã€è¡Œãƒ‡ãƒ¼ã‚¿è‡ªä½“ã«ç›´æ›¸ãã—ã¦ç®¡ç†ã™ã‚‹
  function makeCell(type, extra={}) {
    return { type, ...extra }; // cave: { caveId }, exploring overlay: tie to cave state
  }

  // ä¸€è¡Œç”Ÿæˆï¼ˆæ´çªŸã¯ã“ã“ã§é–‹å§‹ãƒ»é…ç½®ï¼‰
  function generateRowWithCaves(queueRowIndex, preplanned=null) {
    // åœŸ/çŸ³ã®åŸºæœ¬é…åˆ†ï¼ˆçŸ³:30%ã€œ40%ç¨‹åº¦ï¼‰
    const row = Array.from({length: COLS}, () => {
      const isStone = chance(0.35);
      return makeCell(isStone ? STONE : DIRT);
    });

    // æ—¢ã«äº‹å‰é…ç½®ï¼ˆä¸Šä½ã‹ã‚‰ã®æ´çªŸæ‹¡å¼µï¼‰ãŒã‚ã‚Œã°é©ç”¨
    if (preplanned) {
      for (const {c, caveId} of preplanned) {
        row[c] = makeCell(CAVE, { caveId });
      }
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ã§æ–°è¦æ´çªŸã‚’é–‹å§‹ï¼ˆå°:ã‚„ã‚„å‡ºã‚„ã™ã„ / ä¸­:ãŸã¾ã« / å¤§:ã¾ã‚Œï¼‰
    // è¤‡æ•°ã¯é¿ã‘ã€1è¡Œã«ã¤ãæœ€å¤§1ã¤ã®é–‹å§‹ã«ã—ã¦ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
    if (!row.some(cell => cell.type === CAVE)) {
      const roll = Math.random();
      let size = 0;
      if (roll < 0.06) size = 3;
      else if (roll < 0.14) size = 2;
      else if (roll < 0.28) size = 1;

      if (size > 0) {
        const startCols = COLS - size + 1;
        const c0 = rand(0, startCols - 1);

        // ã“ã®è¡Œã‹ã‚‰ä¸‹ã« size è¡Œå¿…è¦ã€‚queue å´ã®å°†æ¥è¡Œã«åŸ‹ã‚ã‚‹
        const caveId = caveSeq++;
        const cellsRefs = [];

        // å¯è¦–ã‚„ã‚­ãƒ¥ãƒ¼ã«ã¾ãŸãŒã‚‹ãŸã‚ã€ã¨ã‚Šã‚ãˆãšã“ã®è¡Œã¯é…ç½®
        for (let dc=0; dc<size; dc++) {
          const col = c0 + dc;
          row[col] = makeCell(CAVE, { caveId });
          cellsRefs.push({ r: null, c: col }); // r ã¯å¯è¦–ã«å…¥ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ç¢ºå®š
        }

        // å°†æ¥ã® (size-1) è¡Œã«ã‚‚é…ç½®äºˆç´„ã‚’å…¥ã‚Œã‚‹
        ensureQueueLength(queueRowIndex + size); // size è¡Œå…ˆã¾ã§ç¢ºä¿
        for (let dr=1; dr<size; dr++) {
          const targetRow = queue[queueRowIndex + dr];
          for (let dc=0; dc<size; dc++) {
            const col = c0 + dc;
            targetRow[col] = makeCell(CAVE, { caveId });
            cellsRefs.push({ r: null, c: col });
          }
        }

        // æ´çªŸçŠ¶æ…‹ã‚’æº–å‚™ï¼ˆstate ã¯å…±æœ‰ï¼‰
        caves.set(caveId, { size, state:'idle', endAt:0, cells: cellsRefs });
      }
    }

    return row;
  }

  function ensureQueueLength(minLen){
    while(queue.length < minLen){
      // äºˆå‚™è¡Œã¯äº‹å‰é…ç½®ãªã—ã§ä»®åŸ‹ã‚ï¼ˆå¾Œã§ generateRowWithCaves ã§ç½®æ›ã•ã‚Œã‚‹å¯èƒ½æ€§ï¼‰
      queue.push(Array.from({length: COLS}, () => makeCell(chance(0.35)?STONE:DIRT)));
    }
  }

  function fillQueue(initial=false){
    const target = initial ? 40 : 12; // åˆæœŸã¯å¤šã‚ã«å…ˆèª­ã¿
    let i = queue.length;
    while(queue.length < target){
      const row = generateRowWithCaves(i);
      queue.push(row);
      i++;
    }
  }

  // ====== åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ======
  function init() {
    visible = [];
    queue = [];
    caves.clear();
    caveSeq = 1;

    fillQueue(true);

    // å¯è¦–è¡Œã‚’å…ˆé ­ã‹ã‚‰7è¡Œå–ã‚Šå‡ºã™
    for(let i=0;i<ROWS;i++){
      visible.push(queue.shift());
    }

    renderAll();
    loop();
  }

  // ====== æç”» ======
  function renderAll(){
    renderStats();
    renderGrid();
    renderUpgrades();
  }

  function renderStats(){
    $scoreVal.textContent = Math.floor(score);
    $depthVal.textContent = depth;
    $pickVal.textContent = pick;
    $pickMax.textContent = pickMax;

    const rate = regenPerSec();
    // è¡¨ç¤ºã¯ "x/ys" ã®æ„Ÿã˜ã§ã–ã£ãã‚Š
    const per = rate.toFixed(2) + "/s";
    $regenInfo.textContent = per;
    $uRegenRate.textContent = per;
  }

  function cellImgSrc(cell){
    if(cell.type === DIRT) return 'dirt.png';
    if(cell.type === STONE) return 'stone.png';
    if(cell.type === CAVE) return 'cave.png';
    return '';
  }

  function renderGrid(){
    // ã‚¯ãƒªã‚¢
    $grid.innerHTML = '';
    // ã‚°ãƒªãƒƒãƒ‰ã‚’æãï¼ˆä¸Šâ†’ä¸‹ï¼‰
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const cell = visible[r][c];
        const div = document.createElement('div');
        div.className = 'cell';
        div.dataset.r = r;
        div.dataset.c = c;

        if (cell.type !== EMPTY){
          const img = document.createElement('img');
          img.src = cellImgSrc(cell);
          div.appendChild(img);
        }

        if (cell.type === CAVE){
          // æ´çªŸã®çŠ¶æ…‹æç”»
          const cav = caves.get(cell.caveId);
          if (cav){
            const ov = document.createElement('div');
            ov.className = 'overlay';
            let txt = '';
            if (cav.state === 'idle') txt = '';
            else if (cav.state === 'exploring') {
              const remain = Math.max(0, Math.ceil((cav.endAt - Date.now())/1000));
              txt = 'æ¢ç´¢ä¸­â€¦ ' + remain + 's';
              // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
              const pr = document.createElement('div');
              pr.className = 'progress';
              const fill = document.createElement('i');
              const total = CAVE_INFO[cav.size].secs;
              const done = Math.min(1, 1 - (remain/total));
              fill.style.width = (done*100).toFixed(1)+'%';
              pr.appendChild(fill);
              div.appendChild(pr);
            } else if (cav.state === 'done') {
              txt = 'å›åOK';
            }
            ov.textContent = txt;
            div.appendChild(ov);
          }
        }

        // ãƒãƒ³ãƒ‰ãƒ©
        div.addEventListener('click', onCellTap, {passive:true});
        $grid.appendChild(div);
      }
    }
  }

  function renderUpgrades(){
    $uRegenLvl.textContent = regenLvl;
    $uMaxLvl.textContent = maxLvl;
    $uPtsLvl.textContent = ptsLvl;
    $uCaveLvl.textContent = caveLvl;

    $uMaxNow.textContent = pickMax;
    $uPtsNow.textContent = (1 + 0.1*ptsLvl).toFixed(2) + 'Ã—';

    $uRegenCost.textContent = priceRegen().toString() + 'pt';
    $uMaxCost.textContent   = priceMax().toString() + 'pt';
    $uPtsCost.textContent   = pricePts().toString() + 'pt';
    $uCaveCost.textContent  = priceCave().toString() + 'pt';
  }

  // ====== ãƒ­ã‚¸ãƒƒã‚¯ ======
  function onCellTap(e){
    const target = e.currentTarget;
    const r = +target.dataset.r;
    const c = +target.dataset.c;
    const cell = visible[r][c];

    if (!cell || cell.type === EMPTY) return;

    if (cell.type === DIRT || cell.type === STONE){
      const need = COST_PICK[cell.type];
      if (pick < need) {
        pulse(target);
        return;
      }
      pick -= need;

      const mult = 1 + 0.1*ptsLvl;
      const gain = Math.round(BASE_POINTS[cell.type] * mult);
      score += gain;

      // æ˜ã£ãŸ
      visible[r][c] = makeCell(EMPTY);
      pickaxeFx(target, cell.type);

      // ä¸‹æ®µãªã‚‰1mé€²ã‚ã¦ã‚·ãƒ•ãƒˆ
      if (r === ROWS-1) {
        depth += 1;
        shiftDown();
      }

      renderStats();
      // ä¸‹æ®µã§ãªã„å ´åˆã‚‚ã€ãã®ã‚»ãƒ«ã ã‘æ›´æ–°ã—ãŸã„ã‘ã©ã€ç°¡å˜ã«å…¨ä½“å†æç”»
      renderGrid();
      return;
    }

    if (cell.type === CAVE){
      const cav = caves.get(cell.caveId);
      if (!cav) return;

      if (cav.state === 'idle'){
        cav.state = 'exploring';
        cav.endAt = Date.now() + CAVE_INFO[cav.size].secs * 1000;
        renderGrid();
      } else if (cav.state === 'done'){
        // å ±é…¬å—ã‘å–ã‚Šï¼šã‚¹ã‚³ã‚¢ + ãƒ”ãƒƒã‚±ãƒ«
        const info = CAVE_INFO[cav.size];
        const ptsMult = 1 + 0.1*ptsLvl;
        const caveMult = 1 + 0.2*caveLvl;
        const gainScore = Math.round(info.baseScore * ptsMult * caveMult);
        const gainPick = Math.max(1, Math.round(info.basePicks * caveMult));

        score += gainScore;
        pick = Math.min(pickMax, pick + gainPick);

        // ã‚»ãƒ«ã‚’ç©ºã«
        for (const pos of cav.cells){
          // pos.r ã¯å¯è¦–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸å®š â†’ ç¾åœ¨ã®å¯è¦–ã«å­˜åœ¨ã™ã‚‹ãªã‚‰æ¶ˆã™
          // åŒä¸€ caveId ã‚’æŒã¤ã‚»ãƒ«ã‚’å¯è¦–ã‹ã‚‰æ¢ã—ã¦ç©ºã«
        }
        // å¯è¦–ã‚°ãƒªãƒƒãƒ‰ã‚’ç›´æ¥èµ°æŸ»ã—ã¦è©²å½“ caveId ã‚’ç©ºã¸
        for (let rr=0; rr<ROWS; rr++){
          for (let cc=0; cc<COLS; cc++){
            const cl = visible[rr][cc];
            if (cl.type === CAVE && cl.caveId === cell.caveId){
              visible[rr][cc] = makeCell(EMPTY);
            }
          }
        }
        caves.delete(cell.caveId);

        toast(target, `+${gainScore}pt / +${gainPick}â›ï¸`);
        renderAll();
      } else {
        // exploring ä¸­ã¯ä½•ã‚‚ã—ãªã„
      }
    }
  }

  function shiftDown(){
    // ä¸€ç•ªä¸Šã‚’æ¨ã¦ã€ä¸‹ã« queue ã‹ã‚‰1è¡Œè£œå……
    visible.shift();
    if (queue.length === 0) fillQueue(false);
    const next = queue.shift();
    visible.push(next);

    // ã¤ã„ã§ã«å…ˆèª­ã¿è£œå……
    fillQueue(false);
  }

  function regenPerSec(){
    return BASE_REGEN_PER_SEC * (1 + 0.2*regenLvl);
  }

  // ====== ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ»è³¼å…¥ ======
  function priceRegen(){ return Math.round(500 * Math.pow(1.6, regenLvl)); }
  function priceMax(){   return Math.round(500 * Math.pow(1.6, maxLvl)); }
  function pricePts(){   return Math.round(800 * Math.pow(1.6, ptsLvl)); }
  function priceCave(){  return Math.round(800 * Math.pow(1.6, caveLvl)); }

  $buy1.addEventListener('click', ()=>{
    if (score >= 100 && pick < pickMax){
      score -= 100;
      pick = Math.min(pickMax, pick + 1);
      renderStats();
    }
  });
  $buy10.addEventListener('click', ()=>{
    const need = Math.min(10, pickMax - pick);
    if (need <= 0) return;
    const cost = 100 * need;
    if (score >= cost){
      score -= cost;
      pick += need;
      renderStats();
    }
  });

  $uRegenBtn.addEventListener('click', ()=>{
    const cost = priceRegen();
    if (score >= cost){
      score -= cost;
      regenLvl += 1;
      renderAll();
    }
  });
  $uMaxBtn.addEventListener('click', ()=>{
    const cost = priceMax();
    if (score >= cost){
      score -= cost;
      maxLvl += 1;
      pickMax = 50 + 10*maxLvl; // ä¸Šé™æ‹¡å¼µï¼ˆæ™‚é–“å›å¾©ã®ä¸Šé™ã‚‚åŒã˜ï¼‰
      // ä¸Šé™ã«åˆã‚ã›ã¦è¡¨ç¤ºæ›´æ–°
      if (pick > pickMax) pick = pickMax;
      renderAll();
    }
  });
  $uPtsBtn.addEventListener('click', ()=>{
    const cost = pricePts();
    if (score >= cost){
      score -= cost;
      ptsLvl += 1;
      renderAll();
    }
  });
  $uCaveBtn.addEventListener('click', ()=>{
    const cost = priceCave();
    if (score >= cost){
      score -= cost;
      caveLvl += 1;
      renderAll();
    }
  });

  // ====== ãƒ«ãƒ¼ãƒ—ï¼ˆå›å¾©ï¼†æ´çªŸé€²è¡Œï¼‰ ======
  let lastTick = performance.now();
  function loop(now = performance.now()){
    const dt = Math.min(0.1, (now - lastTick)/1000); // 100msä¸Šé™
    lastTick = now;

    // ãƒ”ãƒƒã‚±ãƒ«å›å¾©
    if (pick < pickMax){
      regenAcc += regenPerSec() * dt;
      if (regenAcc >= 1){
        const add = Math.floor(regenAcc);
        regenAcc -= add;
        pick = Math.min(pickMax, pick + add);
        // åæ˜ 
        $pickVal.textContent = pick;
      }
    }

    // æ´çªŸã®é€²è¡Œ
    let needRenderGrid = false;
    for (const [id, cav] of caves){
      if (cav.state === 'exploring' && Date.now() >= cav.endAt){
        cav.state = 'done';
        needRenderGrid = true;
      }
    }
    if (needRenderGrid) renderGrid();

    requestAnimationFrame(loop);
  }

  // ====== FX / UI ======
  function pickaxeFx(cellEl, type){
    const bounds = $grid.getBoundingClientRect();
    const rect = cellEl.getBoundingClientRect();

    const fx = document.createElement('div');
    fx.className = 'fx';
    fx.textContent = 'â›ï¸';
    fx.style.left = (rect.left - bounds.left + rect.width*0.15) + 'px';
    fx.style.top  = (rect.top - bounds.top - 6) + 'px';
    $grid.appendChild(fx);
    setTimeout(()=> fx.remove(), 420);

    const sp = document.createElement('div');
    sp.className = 'spark';
    sp.textContent = type === STONE ? 'ğŸ’¥' : 'âœ¨';
    sp.style.left = (rect.left - bounds.left + rect.width*0.55) + 'px';
    sp.style.top  = (rect.top - bounds.top + rect.height*0.35) + 'px';
    $grid.appendChild(sp);
    setTimeout(()=> sp.remove(), 520);
  }

  function pulse(el){
    el.animate([
      {transform:'scale(1)', filter:'brightness(1)'},
      {transform:'scale(0.97)', filter:'brightness(1.25)'},
      {transform:'scale(1)', filter:'brightness(1)'},
    ], {duration:200, easing:'ease-out'});
  }

  function toast(anchor, text){
    const bounds = $grid.getBoundingClientRect();
    const rect = anchor.getBoundingClientRect();
    const tip = document.createElement('div');
    tip.className = 'spark';
    tip.style.fontSize = '14px';
    tip.style.left = (rect.left - bounds.left + rect.width*0.5 - 24) + 'px';
    tip.style.top  = (rect.top - bounds.top - 6) + 'px';
    tip.textContent = text;
    $grid.appendChild(tip);
    setTimeout(()=> tip.remove(), 800);
  }

  // ====== ã‚¹ã‚¿ãƒ¼ãƒˆ ======
  init();
})();
</script>
</body>
</html>
