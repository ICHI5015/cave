<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>鉱山ゲーム</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#111820;
    --accent:#59f5c6;
    --accent-2:#ff7bd5;
    --text:#e9f1f7;
    --muted:#9fb3c8;
    --warn:#ffd166;
    --danger:#ff6b6b;

    --cell: min(12.5vw, 64px); /* スマホ優先サイズ */
    --gap: 6px;
    --radius: 12px;
    --soft: 10px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0; padding:0; background:linear-gradient(180deg,#0b0f14,#0b0f14 60%,#0a0d12); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Helvetica Neue", Arial, "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Emoji", sans-serif;}
  #app{max-width: 480px; margin: 0 auto; padding: 16px 14px 28px;}
  header{
    display:grid; grid-template-columns: 1fr 1fr; grid-auto-rows: auto; gap: 8px;
    position: sticky; top:0; background:linear-gradient(180deg, rgba(11,15,20,.95), rgba(11,15,20,.7) 60%, rgba(11,15,20,0));
    backdrop-filter: blur(6px); padding-bottom: 6px; z-index: 10;
  }
  .card{
    background: linear-gradient(180deg, #0f1621, #0e141d);
    border: 1px solid #1c2633;
    border-radius: var(--radius);
    box-shadow: 0 10px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
  }
  .stat{padding: 10px 12px; display:flex; align-items:center; justify-content: space-between; gap: 10px;}
  .stat b{font-size: 14px; color: var(--muted); font-weight:600;}
  .stat .val{font-size: 18px; font-weight:700; letter-spacing:.2px;}
  .row{display:flex; align-items:center; gap:8px;}
  .pill{
    background: #0b121a;
    border: 1px solid #1b2938;
    border-radius: 999px; padding: 6px 10px; font-size: 12px; color: var(--muted);
  }
  .accent{ color: var(--accent); }
  .accent2{ color: var(--accent-2); }

  /* グリッド */
  #grid{
    margin-top: 10px;
    display: grid;
    grid-template-columns: repeat(6, var(--cell));
    grid-auto-rows: var(--cell);
    gap: var(--gap);
    justify-content: center;
    padding: 12px;
    position: relative;
  }
  .cell{
    width: var(--cell); height: var(--cell);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background: #0d1219;
    border: 1px solid #1a2230;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), inset 0 -10px 18px rgba(0,0,0,.35);
    touch-action: manipulation;
  }
  .cell img{
    width:100%; height:100%; object-fit: cover; display:block; pointer-events:none;
    filter: contrast(1.02) saturate(1.05);
  }
  .cell .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    font-size: 12px; color:#fff; text-shadow: 0 1px 2px rgba(0,0,0,.5);
    background: linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.25));
  }
  .cell .progress{
    position:absolute; left:0; right:0; bottom:0; height:6px; border-radius:6px;
    background: rgba(255,255,255,.06);
  }
  .cell .progress > i{
    display:block; height:100%; width:0%; border-radius:6px;
    background: linear-gradient(90deg, var(--accent), #8afff0);
    box-shadow: 0 0 12px rgba(89,245,198,.5);
  }

  /* ピッケルアニメーション */
  .fx{
    position:absolute; width: 28px; height: 28px; transform-origin: 60% 90%;
    font-size: 22px; line-height: 28px; text-align:center; pointer-events:none;
    animation: swing .38s ease-in-out forwards;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.6));
  }
  @keyframes swing {
    0% { transform: translate(0,0) rotate(-35deg); opacity: 0; }
    40%{ transform: translate(-6px, -8px) rotate(0deg); opacity: 1; }
    100%{ transform: translate(8px, 10px) rotate(30deg); opacity: .05; }
  }
  .spark{
    position:absolute; font-size: 16px; animation: pop .5s ease-out forwards; pointer-events:none;
    filter: drop-shadow(0 2px 6px rgba(255,255,255,.7));
  }
  @keyframes pop{
    0%{ transform: translate(0,0) scale(.7); opacity: 0; }
    30%{ opacity:1; }
    100%{ transform: translate(0,-14px) scale(1.1); opacity:0; }
  }

  /* コントロールエリア */
  #controls{ display:grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
  .panel{ padding: 12px; }
  .buttons{ display:flex; gap:8px; flex-wrap: wrap; }
  button{
    appearance: none; border: 1px solid #1b2938; background: #0b121a; color: var(--text);
    padding: 10px 12px; border-radius: 10px; font-weight: 700; letter-spacing:.2px;
    box-shadow: 0 10px 18px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.03);
  }
  button.primary{
    background: linear-gradient(180deg, #1c2f3f, #132536);
    border-color:#2b4054;
  }
  button:disabled{ opacity:.55; }

  .upg{
    display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
    padding:10px; border-radius:10px; border:1px solid #1b2938; background:#0b121a;
  }
  .upg h4{ margin:0; font-size:14px; }
  .upg small{ color:var(--muted); }
  .upg .lvl{ font-weight:800; color:var(--accent); }
  .upg .cost{ color:var(--warn); font-weight:700; }

  .hint{
    color: var(--muted); font-size: 12px; padding: 4px 2px 0;
  }

  footer{ margin-top: 14px; text-align:center; color: var(--muted); font-size: 11px; }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="card stat">
      <b>スコア</b>
      <div class="val" id="scoreVal">0</div>
    </div>
    <div class="card stat">
      <b>深さ</b>
      <div class="val"><span id="depthVal">0</span> m</div>
    </div>
    <div class="card stat" style="grid-column:1 / -1;">
      <div class="row">
        <b>ピッケル</b>
        <span class="pill"><span id="pickVal">50</span>/<span id="pickMax">50</span></span>
        <span class="pill">回復 <span id="regenInfo">1/5s</span></span>
      </div>
      <div class="row">
        <button id="buy1" class="primary">+1（100pt）</button>
        <button id="buy10" class="primary">+10（1000pt）</button>
      </div>
    </div>
  </header>

  <main class="card panel">
    <div id="grid" aria-label="mine grid"></div>
    
  </main>

  <section id="controls">
    <div class="card panel">
      <h3 style="margin:0 0 8px 0; font-size:16px;">アップグレード</h3>
      <div class="upg">
        <div>
          <h4>ピッケル回復速度アップ <span class="lvl">Lv.<span id="uRegenLvl">0</span></span></h4>
          <small>回復効率 +20%/Lv（現在: <span id="uRegenRate">1/5s</span>）</small>
        </div>
        <button id="uRegenBtn"><span class="cost" id="uRegenCost">500pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>ピッケル最大個数アップ <span class="lvl">Lv.<span id="uMaxLvl">0</span></span></h4>
          <small>上限 +10/Lv（現在: <span id="uMaxNow">50</span>）</small>
        </div>
        <button id="uMaxBtn"><span class="cost" id="uMaxCost">500pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>ポイントアップ <span class="lvl">Lv.<span id="uPtsLvl">0</span></span></h4>
          <small>獲得ポイント +10%/Lv（現在倍率: <span id="uPtsNow">1.00×</span>）</small>
        </div>
        <button id="uPtsBtn"><span class="cost" id="uPtsCost">800pt</span></button>
      </div>
      <div class="upg">
        <div>
          <h4>鉱窟採取個数アップ <span class="lvl">Lv.<span id="uCaveLvl">0</span></span></h4>
          <small>鉱窟の報酬 +20%/Lv</small>
        </div>
        <button id="uCaveBtn"><span class="cost" id="uCaveCost">800pt</span></button>
      </div>
    </div>
  </section>

  <footer>画像: dirt.png / stone.png / cave.png を同じフォルダに置いてね。</footer>
</div>

<script>
(() => {
  // ====== 基本設定 ======
  const COLS = 6;
  const ROWS = 7;

  const DIRT = 'dirt';
  const STONE = 'stone';
  const CAVE = 'cave';
  const EMPTY = 'empty';

  const BASE_POINTS = { dirt: 100, stone: 200 };
  const COST_PICK = { dirt: 1, stone: 2 };

  // 鉱窟サイズと時間（ミリ秒）
  const CAVE_INFO = {
    1: { secs: 30, baseScore: 300, basePicks: 5 },
    2: { secs: 60, baseScore: 800, basePicks: 12 },
    3: { secs: 120, baseScore: 2000, basePicks: 25 },
  };

  // ピッケル回復：ベースは 1本/5秒
  const BASE_REGEN_PER_SEC = 1/5; // 0.2 / sec

  // ====== 状態 ======
  let score = 0;
  let depth = 0;

  let pick = 50;
  let pickMax = 50;
  let regenLvl = 0; // +20%/Lv
  let maxLvl = 0;   // +10 cap / Lv
  let ptsLvl = 0;   // +10%/Lv
  let caveLvl = 0;  // +20%/Lv

  let regenAcc = 0; // 回復の小数累積

  // グリッド可視領域（先頭が最上段、末尾が最下段）
  let visible = []; // [row][col] -> cell object
  // 先読みの行バッファ（新しい下段を補充するためのキュー）
  let queue = [];

  // 鉱窟グループ状態
  let caveSeq = 1;
  const caves = new Map(); // id -> {size, state:'idle'|'exploring'|'done', endAt:number, cells:[{r,c}]}

  // ====== 参照 ======
  const $grid = document.getElementById('grid');
  const $scoreVal = document.getElementById('scoreVal');
  const $depthVal = document.getElementById('depthVal');
  const $pickVal = document.getElementById('pickVal');
  const $pickMax = document.getElementById('pickMax');
  const $regenInfo = document.getElementById('regenInfo');

  const $buy1 = document.getElementById('buy1');
  const $buy10 = document.getElementById('buy10');

  const $uRegenLvl = document.getElementById('uRegenLvl');
  const $uRegenRate = document.getElementById('uRegenRate');
  const $uRegenCost = document.getElementById('uRegenCost');

  const $uMaxLvl = document.getElementById('uMaxLvl');
  const $uMaxNow = document.getElementById('uMaxNow');
  const $uMaxCost = document.getElementById('uMaxCost');

  const $uPtsLvl = document.getElementById('uPtsLvl');
  const $uPtsNow = document.getElementById('uPtsNow');
  const $uPtsCost = document.getElementById('uPtsCost');

  const $uCaveLvl = document.getElementById('uCaveLvl');
  const $uCaveCost = document.getElementById('uCaveCost');

  const $uRegenBtn = document.getElementById('uRegenBtn');
  const $uMaxBtn = document.getElementById('uMaxBtn');
  const $uPtsBtn = document.getElementById('uPtsBtn');
  const $uCaveBtn = document.getElementById('uCaveBtn');

  // ====== 生成ユーティリティ ======
  const rand = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const chance = (p)=> Math.random() < p;

  // 洞窟の事前配置用マスク：queueインデックス基準で (rowIdx)->Set of col で埋めるのではなく、行データ自体に直書きして管理する
  function makeCell(type, extra={}) {
    return { type, ...extra }; // cave: { caveId }, exploring overlay: tie to cave state
  }

  // 一行生成（洞窟はここで開始・配置）
  function generateRowWithCaves(queueRowIndex, preplanned=null) {
    // 土/石の基本配分（石:30%〜40%程度）
    const row = Array.from({length: COLS}, () => {
      const isStone = chance(0.35);
      return makeCell(isStone ? STONE : DIRT);
    });

    // 既に事前配置（上位からの洞窟拡張）があれば適用
    if (preplanned) {
      for (const {c, caveId} of preplanned) {
        row[c] = makeCell(CAVE, { caveId });
      }
    }

    // ランダムで新規洞窟を開始（小:やや出やすい / 中:たまに / 大:まれ）
    // 複数は避け、1行につき最大1つの開始にしてバランス調整
    if (!row.some(cell => cell.type === CAVE)) {
      const roll = Math.random();
      let size = 0;
      if (roll < 0.06) size = 3;
      else if (roll < 0.14) size = 2;
      else if (roll < 0.28) size = 1;

      if (size > 0) {
        const startCols = COLS - size + 1;
        const c0 = rand(0, startCols - 1);

        // この行から下に size 行必要。queue 側の将来行に埋める
        const caveId = caveSeq++;
        const cellsRefs = [];

        // 可視やキューにまたがるため、とりあえずこの行は配置
        for (let dc=0; dc<size; dc++) {
          const col = c0 + dc;
          row[col] = makeCell(CAVE, { caveId });
          cellsRefs.push({ r: null, c: col }); // r は可視に入るタイミングで確定
        }

        // 将来の (size-1) 行にも配置予約を入れる
        ensureQueueLength(queueRowIndex + size); // size 行先まで確保
        for (let dr=1; dr<size; dr++) {
          const targetRow = queue[queueRowIndex + dr];
          for (let dc=0; dc<size; dc++) {
            const col = c0 + dc;
            targetRow[col] = makeCell(CAVE, { caveId });
            cellsRefs.push({ r: null, c: col });
          }
        }

        // 洞窟状態を準備（state は共有）
        caves.set(caveId, { size, state:'idle', endAt:0, cells: cellsRefs });
      }
    }

    return row;
  }

  function ensureQueueLength(minLen){
    while(queue.length < minLen){
      // 予備行は事前配置なしで仮埋め（後で generateRowWithCaves で置換される可能性）
      queue.push(Array.from({length: COLS}, () => makeCell(chance(0.35)?STONE:DIRT)));
    }
  }

  function fillQueue(initial=false){
    const target = initial ? 40 : 12; // 初期は多めに先読み
    let i = queue.length;
    while(queue.length < target){
      const row = generateRowWithCaves(i);
      queue.push(row);
      i++;
    }
  }

  // ====== 初期セットアップ ======
  function init() {
    visible = [];
    queue = [];
    caves.clear();
    caveSeq = 1;

    fillQueue(true);

    // 可視行を先頭から7行取り出す
    for(let i=0;i<ROWS;i++){
      visible.push(queue.shift());
    }

    renderAll();
    loop();
  }

  // ====== 描画 ======
  function renderAll(){
    renderStats();
    renderGrid();
    renderUpgrades();
  }

  function renderStats(){
    $scoreVal.textContent = Math.floor(score);
    $depthVal.textContent = depth;
    $pickVal.textContent = pick;
    $pickMax.textContent = pickMax;

    const rate = regenPerSec();
    // 表示は "x/ys" の感じでざっくり
    const per = rate.toFixed(2) + "/s";
    $regenInfo.textContent = per;
    $uRegenRate.textContent = per;
  }

  function cellImgSrc(cell){
    if(cell.type === DIRT) return 'dirt.png';
    if(cell.type === STONE) return 'stone.png';
    if(cell.type === CAVE) return 'cave.png';
    return '';
  }

  function renderGrid(){
    // クリア
    $grid.innerHTML = '';
    // グリッドを描く（上→下）
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const cell = visible[r][c];
        const div = document.createElement('div');
        div.className = 'cell';
        div.dataset.r = r;
        div.dataset.c = c;

        if (cell.type !== EMPTY){
          const img = document.createElement('img');
          img.src = cellImgSrc(cell);
          div.appendChild(img);
        }

        if (cell.type === CAVE){
          // 洞窟の状態描画
          const cav = caves.get(cell.caveId);
          if (cav){
            const ov = document.createElement('div');
            ov.className = 'overlay';
            let txt = '';
            if (cav.state === 'idle') txt = '';
            else if (cav.state === 'exploring') {
              const remain = Math.max(0, Math.ceil((cav.endAt - Date.now())/1000));
              txt = '探索中… ' + remain + 's';
              // プログレスバー
              const pr = document.createElement('div');
              pr.className = 'progress';
              const fill = document.createElement('i');
              const total = CAVE_INFO[cav.size].secs;
              const done = Math.min(1, 1 - (remain/total));
              fill.style.width = (done*100).toFixed(1)+'%';
              pr.appendChild(fill);
              div.appendChild(pr);
            } else if (cav.state === 'done') {
              txt = '回収OK';
            }
            ov.textContent = txt;
            div.appendChild(ov);
          }
        }

        // ハンドラ
        div.addEventListener('click', onCellTap, {passive:true});
        $grid.appendChild(div);
      }
    }
  }

  function renderUpgrades(){
    $uRegenLvl.textContent = regenLvl;
    $uMaxLvl.textContent = maxLvl;
    $uPtsLvl.textContent = ptsLvl;
    $uCaveLvl.textContent = caveLvl;

    $uMaxNow.textContent = pickMax;
    $uPtsNow.textContent = (1 + 0.1*ptsLvl).toFixed(2) + '×';

    $uRegenCost.textContent = priceRegen().toString() + 'pt';
    $uMaxCost.textContent   = priceMax().toString() + 'pt';
    $uPtsCost.textContent   = pricePts().toString() + 'pt';
    $uCaveCost.textContent  = priceCave().toString() + 'pt';
  }

  // ====== ロジック ======
  function onCellTap(e){
    const target = e.currentTarget;
    const r = +target.dataset.r;
    const c = +target.dataset.c;
    const cell = visible[r][c];

    if (!cell || cell.type === EMPTY) return;

    if (cell.type === DIRT || cell.type === STONE){
      const need = COST_PICK[cell.type];
      if (pick < need) {
        pulse(target);
        return;
      }
      pick -= need;

      const mult = 1 + 0.1*ptsLvl;
      const gain = Math.round(BASE_POINTS[cell.type] * mult);
      score += gain;

      // 掘った
      visible[r][c] = makeCell(EMPTY);
      pickaxeFx(target, cell.type);

      // 下段なら1m進めてシフト
      if (r === ROWS-1) {
        depth += 1;
        shiftDown();
      }

      renderStats();
      // 下段でない場合も、そのセルだけ更新したいけど、簡単に全体再描画
      renderGrid();
      return;
    }

    if (cell.type === CAVE){
      const cav = caves.get(cell.caveId);
      if (!cav) return;

      if (cav.state === 'idle'){
        cav.state = 'exploring';
        cav.endAt = Date.now() + CAVE_INFO[cav.size].secs * 1000;
        renderGrid();
      } else if (cav.state === 'done'){
        // 報酬受け取り：スコア + ピッケル
        const info = CAVE_INFO[cav.size];
        const ptsMult = 1 + 0.1*ptsLvl;
        const caveMult = 1 + 0.2*caveLvl;
        const gainScore = Math.round(info.baseScore * ptsMult * caveMult);
        const gainPick = Math.max(1, Math.round(info.basePicks * caveMult));

        score += gainScore;
        pick = Math.min(pickMax, pick + gainPick);

        // セルを空に
        for (const pos of cav.cells){
          // pos.r は可視インデックス不定 → 現在の可視に存在するなら消す
          // 同一 caveId を持つセルを可視から探して空に
        }
        // 可視グリッドを直接走査して該当 caveId を空へ
        for (let rr=0; rr<ROWS; rr++){
          for (let cc=0; cc<COLS; cc++){
            const cl = visible[rr][cc];
            if (cl.type === CAVE && cl.caveId === cell.caveId){
              visible[rr][cc] = makeCell(EMPTY);
            }
          }
        }
        caves.delete(cell.caveId);

        toast(target, `+${gainScore}pt / +${gainPick}⛏️`);
        renderAll();
      } else {
        // exploring 中は何もしない
      }
    }
  }

  function shiftDown(){
    // 一番上を捨て、下に queue から1行補充
    visible.shift();
    if (queue.length === 0) fillQueue(false);
    const next = queue.shift();
    visible.push(next);

    // ついでに先読み補充
    fillQueue(false);
  }

  function regenPerSec(){
    return BASE_REGEN_PER_SEC * (1 + 0.2*regenLvl);
  }

  // ====== アップグレード・購入 ======
  function priceRegen(){ return Math.round(500 * Math.pow(1.6, regenLvl)); }
  function priceMax(){   return Math.round(500 * Math.pow(1.6, maxLvl)); }
  function pricePts(){   return Math.round(800 * Math.pow(1.6, ptsLvl)); }
  function priceCave(){  return Math.round(800 * Math.pow(1.6, caveLvl)); }

  $buy1.addEventListener('click', ()=>{
    if (score >= 100 && pick < pickMax){
      score -= 100;
      pick = Math.min(pickMax, pick + 1);
      renderStats();
    }
  });
  $buy10.addEventListener('click', ()=>{
    const need = Math.min(10, pickMax - pick);
    if (need <= 0) return;
    const cost = 100 * need;
    if (score >= cost){
      score -= cost;
      pick += need;
      renderStats();
    }
  });

  $uRegenBtn.addEventListener('click', ()=>{
    const cost = priceRegen();
    if (score >= cost){
      score -= cost;
      regenLvl += 1;
      renderAll();
    }
  });
  $uMaxBtn.addEventListener('click', ()=>{
    const cost = priceMax();
    if (score >= cost){
      score -= cost;
      maxLvl += 1;
      pickMax = 50 + 10*maxLvl; // 上限拡張（時間回復の上限も同じ）
      // 上限に合わせて表示更新
      if (pick > pickMax) pick = pickMax;
      renderAll();
    }
  });
  $uPtsBtn.addEventListener('click', ()=>{
    const cost = pricePts();
    if (score >= cost){
      score -= cost;
      ptsLvl += 1;
      renderAll();
    }
  });
  $uCaveBtn.addEventListener('click', ()=>{
    const cost = priceCave();
    if (score >= cost){
      score -= cost;
      caveLvl += 1;
      renderAll();
    }
  });

  // ====== ループ（回復＆洞窟進行） ======
  let lastTick = performance.now();
  function loop(now = performance.now()){
    const dt = Math.min(0.1, (now - lastTick)/1000); // 100ms上限
    lastTick = now;

    // ピッケル回復
    if (pick < pickMax){
      regenAcc += regenPerSec() * dt;
      if (regenAcc >= 1){
        const add = Math.floor(regenAcc);
        regenAcc -= add;
        pick = Math.min(pickMax, pick + add);
        // 反映
        $pickVal.textContent = pick;
      }
    }

    // 洞窟の進行
    let needRenderGrid = false;
    for (const [id, cav] of caves){
      if (cav.state === 'exploring' && Date.now() >= cav.endAt){
        cav.state = 'done';
        needRenderGrid = true;
      }
    }
    if (needRenderGrid) renderGrid();

    requestAnimationFrame(loop);
  }

  // ====== FX / UI ======
  function pickaxeFx(cellEl, type){
    const bounds = $grid.getBoundingClientRect();
    const rect = cellEl.getBoundingClientRect();

    const fx = document.createElement('div');
    fx.className = 'fx';
    fx.textContent = '⛏️';
    fx.style.left = (rect.left - bounds.left + rect.width*0.15) + 'px';
    fx.style.top  = (rect.top - bounds.top - 6) + 'px';
    $grid.appendChild(fx);
    setTimeout(()=> fx.remove(), 420);

    const sp = document.createElement('div');
    sp.className = 'spark';
    sp.textContent = type === STONE ? '💥' : '✨';
    sp.style.left = (rect.left - bounds.left + rect.width*0.55) + 'px';
    sp.style.top  = (rect.top - bounds.top + rect.height*0.35) + 'px';
    $grid.appendChild(sp);
    setTimeout(()=> sp.remove(), 520);
  }

  function pulse(el){
    el.animate([
      {transform:'scale(1)', filter:'brightness(1)'},
      {transform:'scale(0.97)', filter:'brightness(1.25)'},
      {transform:'scale(1)', filter:'brightness(1)'},
    ], {duration:200, easing:'ease-out'});
  }

  function toast(anchor, text){
    const bounds = $grid.getBoundingClientRect();
    const rect = anchor.getBoundingClientRect();
    const tip = document.createElement('div');
    tip.className = 'spark';
    tip.style.fontSize = '14px';
    tip.style.left = (rect.left - bounds.left + rect.width*0.5 - 24) + 'px';
    tip.style.top  = (rect.top - bounds.top - 6) + 'px';
    tip.textContent = text;
    $grid.appendChild(tip);
    setTimeout(()=> tip.remove(), 800);
  }

  // ====== スタート ======
  init();
})();
</script>
</body>
</html>
