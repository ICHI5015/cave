<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>鉱山ゲーム</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#121824;
    --panel2:#0f1420;
    --text:#e9f1ff;
    --muted:#a6b0c0;
    --accent:#5ee7ff;
    --accent2:#7cffad;
    --danger:#ff5e7a;
    --gold:#ffd76a;
    --tile-gap:6px;
    --cell:56px; /* スマホで指が届く大きさ */
    --radius:14px;
    --shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 600px at 80% -10%, #152035 0%, #0b0f14 50%, #07090d 100%);
    color:var(--text); font-family: ui-rounded, "SF Pro Rounded", "Hiragino Maru Gothic ProN", "Noto Sans JP", system-ui, sans-serif;
    display:flex; flex-direction:column; gap:10px; align-items:center;
  }
  header{
    width:min(560px, 100%); padding:10px 14px; border-radius:18px;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    box-shadow:var(--shadow); display:flex; gap:10px; align-items:center; justify-content:space-between;
    position:sticky; top:0; z-index:5; backdrop-filter: blur(10px);
  }
  .stat{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .chip{
    background:linear-gradient(180deg, #171f30, #0e1422);
    padding:8px 12px; border-radius:999px; box-shadow:var(--shadow); display:flex; align-items:center; gap:8px; font-weight:700;
  }
  .chip small{color:var(--muted); font-weight:600}
  .meter{color:var(--accent2)}
  .score{color:var(--gold)}
  .pick{color:var(--accent)}
  .buy-btn{
    background:linear-gradient(180deg, #1a2438, #121a2c); color:var(--text); border:none; padding:8px 12px; border-radius:999px;
    box-shadow:var(--shadow); font-weight:700; cursor:pointer;
  }
  .buy-btn:active{transform:translateY(1px)}
  main{
    width:min(560px, 100%); display:grid; grid-template-columns: 1fr; gap:10px; padding:0 10px 16px;
  }
  .grid-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-radius:18px; box-shadow:var(--shadow); padding:12px;
  }
  .grid{
    display:grid; grid-template-columns: repeat(6, var(--cell));
    grid-auto-rows: var(--cell);
    gap:var(--tile-gap); justify-content:center;
    touch-action: manipulation;
  }
  .cell{
    width:var(--cell); height:var(--cell); border-radius:12px; position:relative; overflow:hidden;
    background:#1b2232; box-shadow:inset 0 2px 8px rgba(0,0,0,.5), 0 6px 20px rgba(0,0,0,.25);
    user-select:none;
  }
  .tile{
    position:absolute; inset:0; border-radius:12px; background-size:cover; background-position:center;
    display:flex; align-items:center; justify-content:center; font-weight:900; color:#fff;
  }
  .dirt{ background-image:url('dirt.png'); background-color:#7a5234; }
  .stone{ background-image:url('stone.png'); background-color:#5a6572; }
  .cave{ background-image:url('cave.png'); background-color:#2a2f3a; }
  .empty{ background:none; }
  .overlay{
    position:absolute; inset:auto 6px 6px 6px; background:rgba(0,0,0,.45);
    color:var(--text); border-radius:10px; padding:2px 6px; font-size:12px; text-align:center;
  }
  .countdown{ color:var(--accent); font-weight:800 }
  .tap-hint{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#fff; text-shadow:0 2px 8px rgba(0,0,0,.6);
    font-size:12px; background:rgba(0,0,0,.18);
  }
  .shake{
    animation:shake .25s ease-in-out both;
  }
  @keyframes shake{
    0%{ transform: translate(0,0) rotate(0deg) }
    25%{ transform: translate(2px,-2px) rotate(-10deg) }
    50%{ transform: translate(-2px,1px) rotate(8deg) }
    75%{ transform: translate(1px,2px) rotate(-6deg) }
    100%{ transform: translate(0,0) rotate(0deg) }
  }
  .emojix{
    position:absolute; font-size:22px; pointer-events:none; filter: drop-shadow(0 4px 8px rgba(0,0,0,.6));
    animation:pop .35s ease-out forwards;
  }
  @keyframes pop{
    0%{ opacity:0; transform: translate(-50%,-30%) scale(.6) rotate(-20deg) }
    60%{ opacity:1; transform: translate(-40%,-70%) scale(1.05) rotate(8deg) }
    100%{ opacity:0; transform: translate(-30%,-100%) scale(.9) rotate(0deg) }
  }
  .controls, .upgrades{
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-radius:18px; box-shadow:var(--shadow); padding:12px;
  }
  .ctrl-row, .upg-row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .ctrl-row button, .upg-card button{
    background:linear-gradient(180deg, #1a2438, #121a2c); color:var(--text); border:none; padding:10px 12px; border-radius:12px;
    box-shadow:var(--shadow); font-weight:800; cursor:pointer; min-width:110px;
  }
  .ctrl-row button:active, .upg-card button:active{ transform:translateY(1px) }
  .upgrades h3{ margin:6px 2px 10px; font-size:16px; color:var(--muted) }
  .upg-grid{ display:grid; grid-template-columns: repeat(2, 1fr); gap:10px }
  .upg-card{
    background:linear-gradient(180deg, #151c2c, #0e1422); border-radius:14px; padding:10px; box-shadow:var(--shadow);
    display:flex; flex-direction:column; gap:6px;
  }
  .upg-title{ font-weight:900 }
  .upg-meta{ color:var(--muted); font-size:12px }
  .highlight{ color:var(--accent2) }
  .note{ color:var(--muted); font-size:12px; text-align:center; margin-top:6px }
  /* Fallback if images missing */
  .dirt::after, .stone::after, .cave::after{
    content:""; position:absolute; inset:0; background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(0,0,0,.18));
    border-radius:12px;
  }
</style>
</head>
<body>
  <header>
    <div class="stat">
      <div class="chip"><span>📏</span><small>深度</small><span class="meter" id="depth">0m</span></div>
      <div class="chip"><span>💰</span><small>スコア</small><span class="score" id="score">0</span></div>
      <div class="chip"><span>⛏️</span><small>ピッケル</small><span class="pick" id="pickaxes">50/100</span></div>
    </div>
    <button class="buy-btn" id="buyPick">ピッケル購入 +1 (150pt)</button>
  </header>

  <main>
    <section class="grid-wrap">
      <div id="grid" class="grid" aria-label="鉱山グリッド"></div>
      <p class="note">下段を全部掘るとスクロールして深く潜る。土=100pt(1⛏️)・石=200pt(2⛏️)。</p>
    </section>

    <section class="controls">
      <div class="ctrl-row">
        <button id="reset">リセット</button>
        <button id="spawnCave">鉱窟を召喚(テスト)</button>
      </div>
    </section>

    <section class="upgrades">
      <h3>アップグレード</h3>
      <div class="upg-grid">
        <div class="upg-card">
          <div class="upg-title">ピッケル回復速度アップ</div>
          <div class="upg-meta">現在: <span id="u_regen_level" class="highlight">Lv.0</span> / 次コスト: <span id="u_regen_cost">500</span>pt</div>
          <button id="u_regen_btn">購入</button>
          <div class="upg-meta">ベース5秒→レベルごとに-10%、最小1秒/個</div>
        </div>
        <div class="upg-card">
          <div class="upg-title">ピッケル最大個数アップ</div>
          <div class="upg-meta">現在: <span id="u_max_level" class="highlight">Lv.0</span> (<span id="u_max_cap">100</span>) / 次コスト: <span id="u_max_cost">800</span>pt</div>
          <button id="u_max_btn">購入</button>
          <div class="upg-meta">レベル毎に+20（上限200）</div>
        </div>
        <div class="upg-card">
          <div class="upg-title">ポイントアップ</div>
          <div class="upg-meta">現在: <span id="u_mult_level" class="highlight">Lv.0</span> (×<span id="u_mult_val">1.00</span>) / 次コスト: <span id="u_mult_cost">1000</span>pt</div>
          <button id="u_mult_btn">購入</button>
          <div class="upg-meta">レベル毎に+10%</div>
        </div>
        <div class="upg-card">
          <div class="upg-title">鉱窟採取個数アップ</div>
          <div class="upg-meta">現在: <span id="u_cave_level" class="highlight">Lv.0</span> / 次コスト: <span id="u_cave_cost">700</span>pt</div>
          <button id="u_cave_btn">購入</button>
          <div class="upg-meta">レベル毎に+2個 採取</div>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  // ------------------ 基本設定 ------------------
  const COLS = 6;
  const ROWS = 7; // 表示行数
  const POINTS = { dirt:100, stone:200 };
  const COST_PER_PICK = 150; // スコア購入の1本あたり価格
  const BASE_REGEN_SEC = 5;  // ベース回復間隔（秒）
  const MIN_REGEN_SEC = 1;
  const INIT_PICKS = 50;
  const INIT_MAX = 100;
  const MAX_CAP_HARD = 200;

  // 鉱窟の探索時間（秒）
  const CAVE_TIME = { small:30, medium:60, large:120 };
  // 鉱窟の基礎採取個数
  const CAVE_BASE_HARVEST = { small:4, medium:8, large:16 };

  // 鉱石の出現率（新行生成時）
  const SPAWN = {
    dirt: 0.6,
    stone: 0.35,
    cave: 0.05 // cave は後で実サイズ抽選
  };

  // ------------------ 状態 ------------------
  const state = {
    grid: [],           // 可視領域7行×6列
    depth: 0,           // m
    score: 0,
    pick: INIT_PICKS,
    maxPick: INIT_MAX,
    regenLevel: 0,
    maxLevel: 0,
    multLevel: 0,
    caveLevel: 0,
    lastRegenTime: performance.now(),
    regenResidual: 0,   // サブ秒の積み上げ
    caves: new Map(),   // caveId -> {size,status,remain, cells:[{r,c}], startedAt}
    nextCaveId: 1
  };

  // ------------------ DOM ------------------
  const gridEl = document.getElementById('grid');
  const depthEl = document.getElementById('depth');
  const scoreEl = document.getElementById('score');
  const picksEl = document.getElementById('pickaxes');
  const buyPickBtn = document.getElementById('buyPick');

  const uRegenLevel = document.getElementById('u_regen_level');
  const uRegenCost = document.getElementById('u_regen_cost');
  const uRegenBtn = document.getElementById('u_regen_btn');

  const uMaxLevel = document.getElementById('u_max_level');
  const uMaxCap = document.getElementById('u_max_cap');
  const uMaxCost = document.getElementById('u_max_cost');
  const uMaxBtn = document.getElementById('u_max_btn');

  const uMultLevel = document.getElementById('u_mult_level');
  const uMultVal = document.getElementById('u_mult_val');
  const uMultCost = document.getElementById('u_mult_cost');
  const uMultBtn = document.getElementById('u_mult_btn');

  const uCaveLevel = document.getElementById('u_cave_level');
  const uCaveCost = document.getElementById('u_cave_cost');
  const uCaveBtn = document.getElementById('u_cave_btn');

  const resetBtn = document.getElementById('reset');
  const spawnCaveBtn = document.getElementById('spawnCave');

  // ------------------ ユーティリティ ------------------
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function pointsMult(){
    return 1 + state.multLevel * 0.10;
  }
  function regenIntervalMs(){
    const sec = Math.max(MIN_REGEN_SEC, BASE_REGEN_SEC * Math.pow(0.9, state.regenLevel));
    return sec * 1000;
  }
  function caveExtraHarvest(){
    return state.caveLevel * 2;
  }
  function upgradeCost(kind, level){
    // シンプルな逓増
    switch(kind){
      case 'regen': return Math.floor(500 * Math.pow(1.6, level));
      case 'max':   return Math.floor(800 * Math.pow(1.55, level));
      case 'mult':  return Math.floor(1000* Math.pow(1.75, level));
      case 'cave':  return Math.floor(700 * Math.pow(1.6, level));
    }
  }

  // ------------------ グリッド生成 ------------------
  function makeEmptyCell(){
    return { type:'empty', hp:0, caveId:null };
  }
  function makeBlock(type){
    if(type==='dirt') return { type:'dirt', hp:1, caveId:null };
    if(type==='stone') return { type:'stone', hp:2, caveId:null };
    return makeEmptyCell();
  }

  // 行生成：洞窟は確率的にサイズを選び、置ければ置く
  function generateRow(){
    // まず全セルを dirt/stoneで初期化
    const row = Array.from({length:COLS}, ()=>{
      const r = Math.random();
      if(r < SPAWN.dirt) return makeBlock('dirt');
      if(r < SPAWN.dirt + SPAWN.stone) return makeBlock('stone');
      return makeBlock(Math.random()<0.5 ? 'dirt':'stone'); // fallback
    });

    // 洞窟抽選
    if(Math.random() < SPAWN.cave){
      const sizes = ['small','medium','large'];
      const sizeWeights = [0.6, 0.3, 0.1];
      let p = Math.random();
      let size = 'small';
      if(p > 0.6) size = (p > 0.9) ? 'large' : 'medium';
      // この行単体だと medium/large は縦に必要。上の行にまたがるので、生成はキューして後で配置
      // ここではsmallのみ確実に置く（1x1）。medium/largeは後続ロジックでたまに作る。
      if(size==='small'){
        const c = rand(0,COLS-1);
        row[c] = { type:'cave', size:'small', hp:Infinity, caveId: null, status:'idle' };
      }
    }
    return row;
  }

  // medium/large の洞窟を無理なく時々配置（グリッド全体見て空間があれば置く）
  function tryPlaceBiggerCave(){
    const sizes = [
      {name:'large', w:3,h:3, chance:0.05},
      {name:'medium',w:2,h:2, chance:0.10}
    ];
    for(const s of sizes){
      if(Math.random() < s.chance){
        // 空き領域探索（stone/dirt上でも置く、置いた領域は洞窟化）
        const maxR = ROWS - s.h;
        const maxC = COLS - s.w;
        const r0 = rand(0,maxR);
        const c0 = rand(0,maxC);
        // 重複洞窟は避けたいので、既にcaveなセルが混ざっていたらスキップ
        for(let rr=r0; rr<r0+s.h; rr++){
          for(let cc=c0; cc<c0+s.w; cc++){
            if(state.grid[rr][cc].type==='cave'){ return; }
          }
        }
        // 設置
        const id = state.nextCaveId++;
        const cells = [];
        for(let rr=r0; rr<r0+s.h; rr++){
          for(let cc=c0; cc<c0+s.w; cc++){
            state.grid[rr][cc] = { type:'cave', size:s.name, hp:Infinity, caveId:id, status:'idle' };
            cells.push({r:rr,c:cc});
          }
        }
        state.caves.set(id, { id, size:s.name, status:'idle', remain:CAVE_TIME[s.name], cells, startedAt:null });
      }
    }
  }

  function initGrid(){
    state.grid = [];
    for(let r=0;r<ROWS;r++){
      state.grid.push(generateRow());
    }
    // たまに大きい洞窟
    tryPlaceBiggerCave();
    state.depth = 0;
  }

  // ------------------ レンダリング ------------------
  function render(){
    depthEl.textContent = state.depth + 'm';
    scoreEl.textContent = Math.floor(state.score);
    picksEl.textContent = `${state.pick}/${state.maxPick}`;

    // アップグレード表示
    uRegenLevel.textContent = 'Lv.'+state.regenLevel;
    uRegenCost.textContent = upgradeCost('regen', state.regenLevel);
    uMaxLevel.textContent = 'Lv.'+state.maxLevel;
    uMaxCap.textContent = state.maxPick;
    uMaxCost.textContent = upgradeCost('max', state.maxLevel);
    uMultLevel.textContent = 'Lv.'+state.multLevel;
    uMultVal.textContent = pointsMult().toFixed(2);
    uMultCost.textContent = upgradeCost('mult', state.multLevel);
    uCaveLevel.textContent = 'Lv.'+state.caveLevel;
    uCaveCost.textContent = upgradeCost('cave', state.caveLevel);

    // グリッド
    gridEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className='cell';
        cell.dataset.r=r; cell.dataset.c=c;

        const t = state.grid[r][c];
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.classList.add(t.type);
        if(t.type==='dirt') tile.title='土 100pt / 1⛏️';
        if(t.type==='stone') tile.title='石 200pt / 2⛏️';

        // 洞窟の見た目とカウントダウン
        if(t.type==='cave'){
          // 同じcaveIdの中で左上セルだけにUIを持たせる
          const cid = t.caveId ?? findCaveIdAt(r,c);
          if(cid){
            const cave = state.caves.get(cid);
            if(isTopLeftOfCave(cid, r, c)){
              const ov = document.createElement('div');
              ov.className='overlay';
              const sizeJ = cave.size==='small'?'小':(cave.size==='medium'?'中':'大');
              if(cave.status==='idle'){
                ov.innerHTML = `鉱窟(${sizeJ})`;
              }else if(cave.status==='running'){
                ov.innerHTML = `探索中…<br><span class="countdown">${formatTime(cave.remain)}</span>`;
              }else if(cave.status==='done'){
                ov.innerHTML = `採取完了！<br><span class="countdown">タップで回収</span>`;
              }
              tile.appendChild(ov);
            }
          }else{
            // small 単体はcidないことがあるので、idle風のヒント
            const ov = document.createElement('div');
            ov.className='overlay';
            ov.innerHTML = `鉱窟(小)`;
            tile.appendChild(ov);
          }
        }

        cell.appendChild(tile);
        gridEl.appendChild(cell);
      }
    }
  }

  function isTopLeftOfCave(caveId, r, c){
    const cave = state.caves.get(caveId);
    if(!cave) return false;
    let minR=999, minC=999;
    cave.cells.forEach(p=>{ minR=Math.min(minR,p.r); minC=Math.min(minC,p.c); });
    return r===minR && c===minC;
  }

  function findCaveIdAt(r,c){
    for(const [id,cave] of state.caves.entries()){
      if(cave.cells.some(p=>p.r===r && p.c===c)) return id;
    }
    return null;
  }

  function formatTime(sec){
    sec = Math.max(0, Math.ceil(sec));
    const m = Math.floor(sec/60), s=sec%60;
    return m>0 ? `${m}:${String(s).padStart(2,'0')}` : `0:${String(s).padStart(2,'0')}`;
  }

  // ------------------ 行スクロール ------------------
function checkAndScroll(force=false){
  if(force){
    // 一番上を捨てて、下から新行
    state.grid.shift();
    state.grid.push(generateRow());
    tryPlaceBiggerCave();
    // 洞窟セルの座標更新
    for(const cave of state.caves.values()){
      cave.cells.forEach(p=>p.r = p.r-1);
    }
    // 画面外に消えた洞窟を除去
    for(const [id,cave] of Array.from(state.caves.entries())){
      const stillVisible = cave.cells.some(p => p.r>=0 && p.r<ROWS);
      if(!stillVisible) state.caves.delete(id);
    }
    state.depth += 1;
    render();
  }
}


  // ------------------ 掘る処理 ------------------
  function tryMine(r,c){
    const t = state.grid[r][c];
    if(t.type==='dirt' || t.type==='stone'){
      const cost = t.type==='dirt' ? 1 : 2;
      if(state.pick < cost) return flashCell(r,c,'⛏️不足');
      state.pick -= cost;
      animatePick(r,c);

      // アニメーション感
      const cellEl = getCellEl(r,c);
      if(cellEl) cellEl.classList.add('shake');
      setTimeout(()=>cellEl && cellEl.classList.remove('shake'), 260);

      t.hp -= cost; // 一気に削る（コストでhp=0以下に）
      if(t.hp <= 0){
        // スコア加算（倍率）
        const gained = Math.floor( (POINTS[t.type] || 0) * pointsMult() );
        state.score += gained;
        state.grid[r][c] = makeEmptyCell();
      }
      render();
 if(r === ROWS-1) checkAndScroll(true);

    } else if(t.type==='cave'){
      handleCaveTap(r,c);
    }
  }

  function flashCell(r,c,msg){
    const el = getTileEl(r,c);
    if(!el) return;
    const hint = document.createElement('div');
    hint.className='tap-hint';
    hint.textContent = msg;
    el.appendChild(hint);
    setTimeout(()=>hint.remove(), 450);
  }

  function animatePick(r,c){
    const cell = getCellEl(r,c);
    if(!cell) return;
    const em = document.createElement('div');
    em.className='emojix';
    em.textContent='⛏️';
    em.style.left='50%';
    em.style.top='50%';
    cell.appendChild(em);
    setTimeout(()=>em.remove(), 360);
  }

  function getCellEl(r,c){
    return gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  }
  function getTileEl(r,c){
    const cell = getCellEl(r,c);
    return cell ? cell.querySelector('.tile') : null;
  }

  // ------------------ 鉱窟処理 ------------------
  function handleCaveTap(r,c){
    const id = findCaveIdAt(r,c);
    let cave;
    if(id){
      cave = state.caves.get(id);
    }else{
      // small単発（1x1）をその場で登録
      const newId = state.nextCaveId++;
      cave = { id:newId, size:'small', status:'idle', remain:CAVE_TIME.small, cells:[{r,c}], startedAt:null };
      state.caves.set(newId, cave);
      state.grid[r][c].caveId = newId;
    }

    if(cave.status==='idle'){
      cave.status='running';
      cave.remain=CAVE_TIME[cave.size];
      cave.startedAt = performance.now();
    }else if(cave.status==='running'){
      // なにもしない（進行中）
    }else if(cave.status==='done'){
      // 採取結果を回収して洞窟を消す
      harvestFromCave(cave);
      // 洞窟セルを空に戻す
      cave.cells.forEach(p => state.grid[p.r][p.c] = makeEmptyCell());
      state.caves.delete(cave.id);
      render();
      checkAndScroll();
    }
  }

  function harvestFromCave(cave){
    // いま見えてる掘れるブロックからランダムにいくつか自動採取（ポイントのみ獲得、ピッケル消費なし）
    const candidates = [];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const t = state.grid[r][c];
        if(t.type==='dirt' || t.type==='stone'){
          candidates.push({r,c,type:t.type});
        }
      }
    }
    const base = CAVE_BASE_HARVEST[cave.size] || 4;
    const total = base + caveExtraHarvest();
    let picks = Math.min(total, candidates.length);
    let gained = 0;

    // 近いセルを優先（洞窟の重心に近い順）
    const cx = cave.cells.reduce((a,p)=>a+p.c,0)/cave.cells.length;
    const cy = cave.cells.reduce((a,p)=>a+p.r,0)/cave.cells.length;
    candidates.sort((A,B)=>{
      const dA = (A.c-cx)**2 + (A.r-cy)**2;
      const dB = (B.c-cx)**2 + (B.r-cy)**2;
      return dA - dB;
    });

    for(let i=0;i<picks;i++){
      const it = candidates[i];
      const val = Math.floor( (POINTS[it.type]||0) * pointsMult() );
      gained += val;
      // 消す
      state.grid[it.r][it.c] = makeEmptyCell();
      // ちょい演出
      sparkAt(it.r,it.c);
    }
    state.score += gained;
  }

  function sparkAt(r,c){
    const el = getCellEl(r,c);
    if(!el) return;
    const em = document.createElement('div');
    em.className='emojix';
    em.textContent = '💥';
    em.style.left='50%'; em.style.top='50%';
    el.appendChild(em);
    setTimeout(()=>em.remove(), 360);
  }

  function tickCaves(dt){
    for(const cave of state.caves.values()){
      if(cave.status==='running'){
        cave.remain -= dt/1000;
        if(cave.remain <= 0){
          cave.remain = 0; cave.status='done';
        }
      }
    }
  }

  // ------------------ ピッケル回復/購入 ------------------
  function regenTick(dt){
    // サブタイム管理で決まった間隔ごとに+1
    const interval = regenIntervalMs();
    state.regenResidual += dt;
    while(state.regenResidual >= interval){
      state.regenResidual -= interval;
      if(state.pick < state.maxPick){
        state.pick++;
      }else{
        // いっぱいなら残余をリセットして無駄回し防止
        state.regenResidual = 0;
        break;
      }
    }
  }

  function buyPick(){
    if(state.score >= COST_PER_PICK && state.pick < state.maxPick){
      state.score -= COST_PER_PICK;
      state.pick += 1;
      render();
    }
  }

  // ------------------ アップグレード購入 ------------------
  function tryBuyUpgrade(kind){
    const level = kind==='regen'? state.regenLevel :
                  kind==='max'  ? state.maxLevel   :
                  kind==='mult' ? state.multLevel  :
                  state.caveLevel;
    const cost = upgradeCost(kind, level);
    if(state.score < cost) return;

    state.score -= cost;
    if(kind==='regen'){
      state.regenLevel++;
      // 即時体感のため、残余をリセット（新間隔に馴染ませる）
      state.regenResidual = 0;
    }else if(kind==='max'){
      state.maxLevel++;
      state.maxPick = clamp(INIT_MAX + state.maxLevel*20, INIT_MAX, MAX_CAP_HARD);
      state.pick = Math.min(state.pick, state.maxPick);
    }else if(kind==='mult'){
      state.multLevel++;
    }else if(kind==='cave'){
      state.caveLevel++;
    }
    render();
  }

  // ------------------ 入力 ------------------
  gridEl.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell');
    if(!cell) return;
    const r = +cell.dataset.r;
    const c = +cell.dataset.c;
    tryMine(r,c);
  });

  buyPickBtn.addEventListener('click', buyPick);
  resetBtn.addEventListener('click', ()=>{
    // すべて初期化
    state.score = 0;
    state.pick = INIT_PICKS;
    state.maxPick = INIT_MAX;
    state.regenLevel = 0;
    state.maxLevel = 0;
    state.multLevel = 0;
    state.caveLevel = 0;
    state.caves.clear();
    state.nextCaveId = 1;
    state.regenResidual = 0;
    initGrid();
    render();
  });

  uRegenBtn.addEventListener('click', ()=>tryBuyUpgrade('regen'));
  uMaxBtn.addEventListener('click', ()=>tryBuyUpgrade('max'));
  uMultBtn.addEventListener('click', ()=>tryBuyUpgrade('mult'));
  uCaveBtn.addEventListener('click', ()=>tryBuyUpgrade('cave'));

  // テスト用：今の領域に中/大をたまに置く
  spawnCaveBtn.addEventListener('click', ()=>{
    tryPlaceBiggerCave();
    render();
  });

  // ------------------ ループ ------------------
  let lastTime = performance.now();
  function loop(now){
    const dt = now - lastTime;
    lastTime = now;

    regenTick(dt);
    tickCaves(dt);

    // 1秒に2回くらい描画（無駄更新を避けたいがシンプルに）
    if(now % 300 < 16) render();

    requestAnimationFrame(loop);
  }

  // ------------------ スタート ------------------
  initGrid();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
