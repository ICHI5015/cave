<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>鉱山ゲーム 6×7</title>
<style>
  :root{
    --bg:#0c0f14;
    --panel:#141a22;
    --panel-2:#0f141b;
    --text:#e9f0ff;
    --muted:#9bb1d0;
    --accent:#4df0c8;
    --accent-2:#6ea8ff;
    --danger:#ff6b6b;
    --gold:#ffdd73;
    --cell:64px;      /* SPは後で縮む */
    --gap:8px;
    --radius:14px;
    --shadow:0 8px 24px rgba(0,0,0,.35);
  }

  @media (max-width:480px){
    :root{ --cell:54px; --gap:6px; --radius:12px; }
  }

  @media (max-width:380px){
    :root{ --cell:48px; --gap:5px; --radius:10px; }
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; background:linear-gradient(180deg,#0b0e13,#0a0d12 40%,#080b0f); color:var(--text); font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", sans-serif; }
  body{ margin:0; display:flex; flex-direction:column; gap:10px; }

  .topbar{
    position:sticky; top:0; z-index:10;
    display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px;
    padding:12px 12px 0;
    background:linear-gradient(180deg,rgba(12,15,20,.95),rgba(12,15,20,.65),transparent);
    backdrop-filter:saturate(1.2) blur(8px);
  }

  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid rgba(255,255,255,.06);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:10px 12px;
    min-height:56px;
    display:flex; flex-direction:column; justify-content:center;
  }

  .row{ display:flex; align-items:center; gap:10px; }
  .label{ font-size:12px; color:var(--muted); letter-spacing:.2px; }
  .value{ font-weight:700; font-size:18px; line-height:1.2; }

  .pick-wrap{ display:flex; align-items:center; gap:8px; }
  .pick-count{ font-variant-numeric:tabular-nums; }
  .bar{ position:relative; height:8px; background:#0a1118; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.06); }
  .bar > i{ position:absolute; inset:0; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); }

  .main{
    flex:1; display:flex; flex-direction:column; gap:12px;
    padding:0 12px 12px;
  }

  .grid{
    margin:0 auto;
    display:grid; grid-template-columns: repeat(6, var(--cell));
    grid-template-rows: repeat(7, var(--cell));
    gap:var(--gap);
    touch-action:manipulation;
    user-select:none;
    position:relative;
  }

  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:10px;
    background:#111820;
    border:1px solid rgba(255,255,255,.05);
    overflow:hidden; position:relative;
  }
  .cell > img{ width:100%; height:100%; object-fit:cover; display:block; filter:saturate(1.05) contrast(1.05); }
  .cell.cave::after{
    content:"";
    position:absolute; inset:0;
    background:radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.12), transparent 40%),
               radial-gradient(90% 90% at 80% 70%, rgba(77,240,200,.12), transparent 50%);
    mix-blend-mode:screen; pointer-events:none;
  }

  .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    color:#fff; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,.7);
    background:linear-gradient(180deg,rgba(0,0,0,.0),rgba(0,0,0,.22));
    font-size:12px; letter-spacing:.5px;
  }

  .hud{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
  }

  .btn{
    background:linear-gradient(180deg,#1b2430,#121821);
    color:var(--text);
    border:1px solid rgba(255,255,255,.08);
    padding:10px 12px;
    border-radius:12px;
    font-weight:700; letter-spacing:.2px;
    box-shadow:var(--shadow);
    display:inline-flex; align-items:center; gap:8px;
  }
  .btn:disabled{ opacity:.45; filter:grayscale(.2); }

  .upgrades{
    display:flex; gap:10px; overflow:auto; padding:6px 2px;
  }
  .up{ min-width:220px; }
  .up .label{ font-size:11px; }
  .up .value{ font-size:14px; color:var(--gold); }

  .panel{
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid rgba(255,255,255,.06);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:12px;
  }

  .cave-jobs{ display:flex; gap:10px; overflow:auto; }
  .job{
    min-width:180px;
    background:#101620; border:1px solid rgba(255,255,255,.06);
    border-radius:12px; padding:10px;
  }
  .job .name{ font-weight:800; }
  .job .eta{ font-variant-numeric:tabular-nums; color:var(--muted); font-size:12px; }
  .job .bar{ height:6px; margin-top:6px; }
  .job .bar > i{ background:linear-gradient(90deg,#ffd36b,#ff9e5a); }

  /* ピッケルアニメ */
  .pickaxe{
    position:absolute; z-index:5; pointer-events:none;
    font-size:22px; filter:drop-shadow(0 2px 4px rgba(0,0,0,.5));
    animation: swing .28s ease-out both;
    transform-origin: 70% 20%;
  }
  @keyframes swing{
    0%{ transform: translate(-8px,-8px) rotate(-45deg) scale(1); opacity:0; }
    40%{ opacity:1; }
    100%{ transform: translate(4px,6px) rotate(15deg) scale(1); opacity:0; }
  }

  /* きらり */
  .pop{
    position:absolute; z-index:6; pointer-events:none;
    color:var(--gold); font-weight:800; font-size:14px;
    animation: pop .6s ease-out both;
    text-shadow:0 2px 8px rgba(0,0,0,.5);
  }
  @keyframes pop{
    0%{ transform:translateY(0); opacity:0; }
    10%{ opacity:1; }
    100%{ transform:translateY(-18px); opacity:0; }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="card">
      <div class="label">深度</div>
      <div class="value"><span id="depth">0</span> m</div>
    </div>
    <div class="card">
      <div class="label">スコア</div>
      <div class="value" id="score">0</div>
    </div>
    <div class="card">
      <div class="row">
        <div class="pick-wrap">
          <div class="value"><span id="picks">50</span>/<span id="pickMax">50</span> ⛏️</div>
        </div>
      </div>
      <div class="bar" aria-label="pickaxe regen"><i id="regenBar"></i></div>
    </div>
  </div>

  <div class="main">
    <div class="grid" id="grid" aria-label="mine grid"></div>

    <div class="hud">
      <button class="btn" id="buyPick">⛏️ +1 を購入 (-150)</button>
      <div class="label">土=100pt / 石=200pt（コスト: 土1 / 石2）</div>
    </div>

    <div class="panel">
      <div class="label">アップグレード</div>
      <div class="upgrades" id="upgrades"></div>
    </div>

    <div class="panel">
      <div class="label">鉱窟探索</div>
      <div class="cave-jobs" id="jobs"></div>
    </div>
  </div>

<script>
(function(){
  // 基本設定
  const COLS = 6, ROWS = 7;
  const TYPE = { DIRT:'dirt', STONE:'stone', CAVE:'cave', EMPTY:'empty' };
  const COST = { dirt:1, stone:2 };
  const BASE_PT = { dirt:100, stone:200 };
  const CAVE_SIZE = { small:1, medium:2, large:3 };
  const CAVE_TIME = { small:30, medium:60, large:120 }; // 秒
  const CAVE_BASE_REWARD = { small:300, medium:800, large:1800 }; // ベースpt
  const CAVE_BASE_PICK = { small:1, medium:2, large:4 }; // おまけ⛏️

  // 状態
  let grid = []; // 2D [row][col] 下が最大row-1（視覚は上から並べる）
  let score = 0;
  let depth = 0;

  let pickMax = 50; // 初期上限
  let picks = 50;   // 初期本数
  const HARD_CAP = 100;

  // 回復関連（初期：3秒に1本）
  let regenPer = 3.0; // 秒/1本（小さいほど速い）
  let regenProg = 0;  // 0..1 表示用
  let regenAccum = 0; // 秒累積

  // マルチプライヤ
  let pointMul = 1.0; // ポイントアップ
  let caveMul = 1.0;  // 鉱窟採取数（報酬倍率）

  // アップグレード状態
  const upgrades = {
    speed:{ name:'ピッケル回復速度アップ', lvl:0, baseCost:500, costMul:1.6, effect:()=>{ regenPer = Math.max(0.8, 3.0 * Math.pow(0.85, upgrades.speed.lvl)); } },
    max:{ name:'ピッケル最大個数アップ', lvl:0, baseCost:400, costMul:1.7, effect:()=>{ pickMax = Math.min(HARD_CAP, 50 + upgrades.max.lvl*10); updatePicksUI(); } },
    point:{ name:'ポイントアップ', lvl:0, baseCost:600, costMul:1.7, effect:()=>{ pointMul = 1 + upgrades.point.lvl*0.2; } },
    cave:{ name:'鉱窟採取個数アップ', lvl:0, baseCost:550, costMul:1.65, effect:()=>{ caveMul = 1 + upgrades.cave.lvl*0.25; } },
  };

  // DOM
  const elGrid = document.getElementById('grid');
  const elScore = document.getElementById('score');
  const elDepth = document.getElementById('depth');
  const elPicks = document.getElementById('picks');
  const elPickMax = document.getElementById('pickMax');
  const elRegenBar = document.getElementById('regenBar');
  const elUpgrades = document.getElementById('upgrades');
  const elJobs = document.getElementById('jobs');
  const elBuyPick = document.getElementById('buyPick');

  // 初期化
  function init(){
    grid = [];
    for(let r=0;r<ROWS;r++){
      grid.push(genRow());
    }
    // 最初にちょいだけ洞窟の可能性を低く
    stampRandomCaveOnBottom();

    renderGrid();
    renderUpgrades();
    updateScore(0);
    updateDepth(0);
    updatePicksUI();
  }

  // 行生成（ランダムに土/石）
  function genRow(){
    const row = [];
    for(let c=0;c<COLS;c++){
      const isStone = Math.random() < 0.35; // 35%石
      row.push(makeCell(isStone ? TYPE.STONE : TYPE.DIRT));
    }
    return row;
  }

  function makeCell(type, meta={}){
    return { type, meta:{ ...meta } };
  }

  // ランダムで洞窟クラスターをボトムにスタンプ
  function stampRandomCaveOnBottom(){
    const chance = 0.22; // 新行追加時に22%で洞窟
    if(Math.random() > chance) return;

    // サイズ抽選：大はややレア
    const r = Math.random();
    const size = r<0.55 ? CAVE_SIZE.small : (r<0.88 ? CAVE_SIZE.medium : CAVE_SIZE.large);
    const label = size===1?'small':(size===2?'medium':'large');

    // 配置可能な最左x
    const maxLeft = COLS - size;
    const x0 = Math.floor(Math.random()*(maxLeft+1));

    // ボトムから size 行ぶんにスタンプ（足りなければある分だけ）
    for(let dy=0; dy<size; dy++){
      const rr = ROWS-1 - dy; // 下から上へ
      if(rr<0) break;
      for(let dx=0; dx<size; dx++){
        const cc = x0 + dx;
        // セルを洞窟に
        grid[rr][cc] = makeCell(TYPE.CAVE, { caveId: null, size, label });
      }
    }

    // 洞窟ジョブを作成＆開始
    startCaveJob({ size, label, area:size*size, progress:0, t:0, dur:CAVE_TIME[label] });
  }

  // 洞窟ジョブ
  let caveJobs = [];
  let caveSeq = 1;

  function startCaveJob(job){
    const id = caveSeq++;
    job.id = id;
    caveJobs.push(job);

    // スタンプしたセルに id を刻む（最新の洞窟に付ける）
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if(cell.type===TYPE.CAVE && !cell.meta.caveId && cell.meta.size===job.size){
          cell.meta.caveId = id;
        }
      }
    }
    renderJobs();
  }

  function completeCaveJob(job){
    // 報酬（倍率適用）
    const baseP = CAVE_BASE_REWARD[job.label];
    const baseK = CAVE_BASE_PICK[job.label];
    const pts = Math.round(baseP * pointMul * caveMul);
    const ks  = Math.max(0, Math.floor(baseK * caveMul));

    updateScore(pts);
    addPicks(ks);

    // 洞窟セルを空に（掘り切った扱い）
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if(cell.type===TYPE.CAVE && cell.meta.caveId===job.id){
          grid[r][c] = makeCell(TYPE.EMPTY);
        }
      }
    }
    caveJobs = caveJobs.filter(j=>j.id!==job.id);
    renderJobs();
    renderGrid();
    flashFloat(elGrid, `+${pts}pt ⛏️+${ks}`, {color:'#ffdd73'});
  }

  // 採掘
  function mineCell(r, c){
    const cell = grid[r][c];
    if(!cell) return;

    if(cell.type===TYPE.EMPTY) return;
    if(cell.type===TYPE.CAVE){
      // 洞窟は自動探索。クリックでは何もしない
      flashFloatCell(r,c,'探索中…',{color:'#6ea8ff'});
      return;
    }

    const t = cell.type;
    const need = COST[t];
    if(picks < need){
      flashFloatCell(r,c,'⛏️不足',{color:'#ff6b6b'});
      return;
    }

    // ピッケル消費
    addPicks(-need);

    // ピッケルアニメ
    spawnPickaxeFX(r,c);

    // スコア加算（倍率）
    const gain = Math.round(BASE_PT[t] * pointMul);
    updateScore(gain);
    flashFloatCell(r,c,`+${gain}`,{color:'#ffdd73'});

    // 採掘済みに
    grid[r][c] = makeCell(TYPE.EMPTY);
    renderCell(r,c);

    // 一番下の段だったらスクロール＆+1m
    if(r === ROWS-1){
      shiftDownOne();
      updateDepth(1);
      // 新しい一番下に洞窟抽選
      stampRandomCaveOnBottom();
      renderGrid();
    }
  }

  function shiftDownOne(){
    // 上の段を消し、下に新しい行
    grid.shift();            // 先頭（最上段）を削除
    grid.push(genRow());     // 新規行を最下段に
  }

  // UI更新
  function updateScore(delta){
    score += delta;
    if(score<0) score = 0;
    elScore.textContent = score;
    refreshButtons();
  }

  function updateDepth(delta){
    depth += delta;
    elDepth.textContent = depth;
  }

  function updatePicksUI(){
    if(picks > pickMax) picks = pickMax;
    elPicks.textContent = picks;
    elPickMax.textContent = pickMax;
  }

  function addPicks(n){
    picks = Math.max(0, Math.min(pickMax, picks + n));
    updatePicksUI();
  }

  function refreshButtons(){
    // 購入ボタン
    elBuyPick.disabled = score < 150 || picks >= pickMax;
    // アプグレ
    for(const btn of elUpgrades.querySelectorAll('button[data-key]')){
      const key = btn.getAttribute('data-key');
      const cost = getUpgradeCost(key);
      btn.disabled = score < cost || (key==='max' && pickMax>=HARD_CAP);
      btn.querySelector('.u-cost').textContent = cost;
      btn.querySelector('.u-lvl').textContent = upgrades[key].lvl;
    }
  }

  // グリッド描画
  function renderGrid(){
    elGrid.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        const div = document.createElement('div');
        div.className = 'cell';
        div.dataset.r = r;
        div.dataset.c = c;

        const img = document.createElement('img');
        if(cell.type===TYPE.DIRT){
          img.src = 'dirt.png';
          img.alt = 'dirt';
        }else if(cell.type===TYPE.STONE){
          img.src = 'stone.png';
          img.alt = 'stone';
        }else if(cell.type===TYPE.CAVE){
          img.src = 'cave.png';
          img.alt = 'cave';
          div.classList.add('cave');
          const ov = document.createElement('div');
          ov.className='overlay';
          ov.textContent = '鉱窟';
          div.appendChild(ov);
        }else{
          img.style.opacity = .08;
        }
        div.appendChild(img);
        elGrid.appendChild(div);
      }
    }
  }

  function renderCell(r,c){
    const idx = r*COLS + c;
    const div = elGrid.children[idx];
    const cell = grid[r][c];
    if(!div) return;
    div.className = 'cell';
    div.innerHTML = '';
    const img = document.createElement('img');
    if(cell.type===TYPE.DIRT){
      img.src='dirt.png'; img.alt='dirt';
    }else if(cell.type===TYPE.STONE){
      img.src='stone.png'; img.alt='stone';
    }else if(cell.type===TYPE.CAVE){
      img.src='cave.png'; img.alt='cave';
      div.classList.add('cave');
      const ov = document.createElement('div');
      ov.className='overlay';
      ov.textContent='鉱窟';
      div.appendChild(ov);
    }else{
      img.style.opacity=.08;
    }
    div.appendChild(img);
  }

  // クリック/タップ
  elGrid.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell');
    if(!cell) return;
    const r = +cell.dataset.r;
    const c = +cell.dataset.c;
    if(Number.isFinite(r)&&Number.isFinite(c)){
      mineCell(r,c);
    }
  });

  // ピッケル購入
  elBuyPick.addEventListener('click', ()=>{
    const cost = 150;
    if(score < cost) return;
    if(picks >= pickMax) return;
    updateScore(-cost);
    addPicks(1);
    flashFloat(elBuyPick, '⛏️ +1', {color:'#4df0c8'});
  });

  // アップグレードUI
  function getUpgradeCost(key){
    const u = upgrades[key];
    return Math.round(u.baseCost * Math.pow(u.costMul, u.lvl));
  }

  function renderUpgrades(){
    elUpgrades.innerHTML = '';
    for(const [key,u] of Object.entries(upgrades)){
      const card = document.createElement('div');
      card.className = 'card up';
      const btn = document.createElement('button');
      btn.className = 'btn'; btn.setAttribute('data-key', key);
      btn.innerHTML = `
        <div style="text-align:left">
          <div class="label">${u.name}</div>
          <div class="value">Lv.<span class="u-lvl">${u.lvl}</span> / Cost: <span class="u-cost">${getUpgradeCost(key)}</span></div>
        </div>
      `;
      btn.addEventListener('click', ()=>{
        const cost = getUpgradeCost(key);
        if(score < cost) return;
        updateScore(-cost);
        u.lvl++;
        u.effect();
        refreshButtons();
        flashFloat(btn, 'UP!', {color:'#6ea8ff'});
      });
      card.appendChild(btn);
      elUpgrades.appendChild(card);
    }
    refreshButtons();
  }

  // 洞窟ジョブ表示
  function renderJobs(){
    elJobs.innerHTML = '';
    if(caveJobs.length===0){
      const hint = document.createElement('div');
      hint.className='label';
      hint.textContent = '今は探索なし。掘り進めると見つかるかも。';
      elJobs.appendChild(hint);
      return;
    }
    for(const job of caveJobs){
      const d = document.createElement('div');
      d.className='job';
      const name = job.size===1?'小さな鉱窟':(job.size===2?'中くらいの鉱窟':'大きな鉱窟');
      d.innerHTML = `
        <div class="name">${name}</div>
        <div class="eta"><span class="t">${Math.ceil(job.dur - job.t)}</span> 秒</div>
        <div class="bar"><i style="width:${(job.t/job.dur)*100}%"></i></div>
      `;
      elJobs.appendChild(d);
      job._el = d;
    }
  }

  // ループ（回復＆洞窟）
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.1, (now - last)/1000); // 秒
    last = now;

    // ピッケル回復
    if(picks < pickMax){
      regenAccum += dt;
      if(regenAccum >= regenPer){
        const n = Math.floor(regenAccum / regenPer);
        regenAccum -= n * regenPer;
        addPicks(n);
      }
      regenProg = regenPer>0 ? (regenAccum/regenPer) : 1;
    }else{
      regenAccum = 0;
      regenProg = 0;
    }
    elRegenBar.style.width = (regenProg*100)+'%';

    // 洞窟ジョブ進行
    for(const job of caveJobs.slice()){
      job.t += dt;
      if(job._el){
        job._el.querySelector('.t').textContent = Math.max(0, Math.ceil(job.dur - job.t));
        job._el.querySelector('.bar > i').style.width = Math.min(100, (job.t/job.dur)*100) + '%';
      }
      if(job.t >= job.dur){
        completeCaveJob(job);
      }
    }

    requestAnimationFrame(loop);
  }

  // 演出
  function spawnPickaxeFX(r,c){
    const rect = elGrid.getBoundingClientRect();
    const cell = elGrid.children[r*COLS + c].getBoundingClientRect();
    const x = cell.left - rect.left + cell.width/2;
    const y = cell.top - rect.top + cell.height/2;

    const span = document.createElement('span');
    span.className='pickaxe';
    span.textContent='⛏️';
    span.style.left = (x - 10) + 'px';
    span.style.top  = (y - 18) + 'px';
    elGrid.appendChild(span);
    setTimeout(()=> span.remove(), 400);
  }

  function flashFloat(target, text, opt={}){
    const rect = target.getBoundingClientRect();
    const host = target.closest('.grid') || document.body;
    const base = host===document.body ? document.body : host;
    const x = rect.left + rect.width/2;
    const y = rect.top;

    const sp = document.createElement('span');
    sp.className='pop';
    sp.textContent = text;
    sp.style.color = opt.color || '#ffdd73';

    const parentRect = base.getBoundingClientRect();
    sp.style.left = (x - parentRect.left - 10) + 'px';
    sp.style.top  = (y - parentRect.top - 10) + 'px';
    base.appendChild(sp);
    setTimeout(()=> sp.remove(), 700);
  }
  function flashFloatCell(r,c,text,opt={}){
    const rect = elGrid.getBoundingClientRect();
    const cell = elGrid.children[r*COLS + c].getBoundingClientRect();
    const x = cell.left - rect.left + cell.width/2;
    const y = cell.top - rect.top + 6;

    const sp = document.createElement('span');
    sp.className='pop';
    sp.textContent = text;
    sp.style.left = (x - 10) + 'px';
    sp.style.top  = (y) + 'px';
    sp.style.color = opt.color || '#ffdd73';
    elGrid.appendChild(sp);
    setTimeout(()=> sp.remove(), 700);
  }

  // スタート
  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
