<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>é‰±å±±ã‚²ãƒ¼ãƒ </title>
  <link rel="icon" type="image/png" href="cave.png">

<style>
  :root{
    --cols: 6;
    --rows: 7;
    --gap: 6px;
    --ui-pad: 10px;
    --cell: min(14.8vw, 62px);
    --radius: 10px;
    --bg: #0b0f14;
    --panel: #101822;
    --panel-2: #0c131c;
    --text: #e9f1ff;
    --muted: #a6b3c6;
    --accent: #56d364;
    --accent-2: #33b3ff;
    --warn: #ffb020;
    --danger: #ff5d5d;
    --shadow: 0 10px 24px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0;background:linear-gradient(180deg,#0b0f14 0%,#0b0f14 40%,#061019 100%);color:var(--text);font-family: ui-sans-serif,system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";}
  .wrap{max-width: calc(var(--cell) * var(--cols) + var(--gap)*(var(--cols)-1) + 24px); margin: 10px auto 80px; padding: 10px;}
  header{
    display:grid; gap:8px; grid-template-columns: 1fr; margin-bottom: 8px;
  }
  .bar{
    background: linear-gradient(180deg,var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid #182332; border-radius:14px; padding:10px; box-shadow: var(--shadow);
    display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:10px;
  }
  .stat{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
  .pill{
    background:#0b1622; border:1px solid #1b2a3d; border-radius:999px; padding:6px 10px; display:flex; align-items:center; gap:8px; color:var(--text); font-weight:600; font-size:14px;
  }
  .pill .small{color:var(--muted); font-weight:600; font-size:12px;}
  .meter{display:flex; align-items:center; gap:6px;}
  .progress{
    width:120px; height:12px; background:#0c1016; border:1px solid #1b2a3d; border-radius:999px; position:relative; overflow:hidden;
  }
  .progress > i{position:absolute; inset:0; width:0%; background: linear-gradient(90deg, #2dd4bf 0%, #22c55e 100%);}
  .grid-wrap{
    background: linear-gradient(180deg, #0b0f14 0%, #0f1622 100%);
    border:1px solid #182332; border-radius:16px; padding:12px; box-shadow: var(--shadow);
  }
  .grid{
    display:grid; grid-template-columns: repeat(var(--cols), var(--cell)); grid-template-rows: repeat(var(--rows), var(--cell));
    gap: var(--gap); justify-content:center; position:relative;
  }
  .cell{
    width:var(--cell); height:var(--cell); border-radius:8px; position:relative; overflow:hidden; transform:translateZ(0);
    background:#0a121c; border:1px solid #182332; box-shadow: inset 0 2px 0 rgba(255,255,255,0.05), inset 0 -3px 4px rgba(0,0,0,0.4);
    display:flex; align-items:center; justify-content:center; cursor:pointer;
  }
  .cell:active{ transform: scale(0.98); }
  .tex{
    position:absolute; inset:0; background-size:cover; background-position:center; filter:brightness(.95) contrast(1.05);
  }
  .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  }
  .cave-timer{
    position:absolute; bottom:6px; left:6px; right:6px; height:6px; border-radius:999px; background:rgba(0,0,0,.35); overflow:hidden; border:1px solid rgba(255,255,255,.07);
  }
  .cave-timer > i{display:block; height:100%; width:0%; background: linear-gradient(90deg, #f59e0b, #10b981);}
  .badge{
    position:absolute; top:6px; right:6px; font-size:11px; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.15); color:#fff;
    background: linear-gradient(180deg, #1e293b, #0f172a);
    text-shadow: 0 1px 0 rgba(0,0,0,.6);
  }
  .pick-anim{
    position:absolute; font-size: clamp(20px, 6vw, 32px); pointer-events:none; transform-origin: 70% 90%;
    animation: swing .35s ease-out forwards;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,.45));
  }
  @keyframes swing{
    0%{ transform: translate(-10%, -10%) rotate(-35deg) scale(1); opacity:0; }
    30%{ opacity:1; }
    60%{ transform: translate(10%,-20%) rotate(20deg) scale(1.05); }
    100%{ transform: translate(20%,-30%) rotate(0deg) scale(.9); opacity:0; }
  }
  .controls{
    display:grid; grid-template-columns: 1fr; gap:10px; margin-top:10px;
  }
  .panel{
    background: linear-gradient(180deg,var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid #182332; border-radius:14px; padding:12px; box-shadow: var(--shadow);
  }
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
  .btn{
    appearance:none; border:1px solid #26374d; background: linear-gradient(180deg, #152132, #0f1a28);
    color:#eaf2ff; padding:10px 12px; border-radius:10px; font-weight:700; letter-spacing:.02em; cursor:pointer;
    box-shadow: 0 2px 0 rgba(255,255,255,.05), inset 0 -2px 0 rgba(0,0,0,.35);
  }
  .btn.small{padding:8px 10px; font-weight:600;}
  .btn:disabled{opacity:.5; cursor:not-allowed; filter:saturate(.5);}
  .btn.accent{border-color:#1f4e3a; background: linear-gradient(180deg, #0f2d22, #0b221a);}
  .btn.blue{border-color:#1a3f66; background: linear-gradient(180deg, #0e2134, #0a1a29);}
  .label{color:var(--muted); font-size:12px;}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  .toast{
    position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); background: #0c1622; color:#eaf2ff; border:1px solid #193149; padding:10px 12px; border-radius:10px; box-shadow: var(--shadow); font-weight:700; pointer-events:none; opacity:0; transition:.25s;
  }
  .toast.show{opacity:1; transform: translateX(-50%) translateY(-6px);}
  footer{color:var(--muted); text-align:center; font-size:12px; margin-top:14px;}
  @media (min-width: 540px){
    .controls{grid-template-columns: 1fr 1fr;}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="bar">
      <div class="stat">
        <span class="pill"><span>â›ï¸</span><span id="picks">50</span>/<span id="picksMax">100</span></span>
        <span class="pill"><span>â­</span><span id="score">0</span>pt</span>
        <span class="pill"><span>ğŸ“</span><span id="depth">0</span> m</span>
      </div>
      <div class="meter">
        <span class="small label">å›å¾©</span>
        <div class="progress"><i id="regenBar"></i></div>
        <span id="regenLabel" class="small mono">+1 / 5s</span>
      </div>
    </div>
  </header>

  <div class="grid-wrap">
    <div id="grid" class="grid" aria-label="mine grid"></div>
  </div>

  <div class="controls">
    <div class="panel">
      <div class="row" style="justify-content:flex-start; gap:6px 10px;">
        <span class="label">ãƒ”ãƒƒã‚±ãƒ«è³¼å…¥ï¼ˆã‚¹ã‚³ã‚¢æ¶ˆè²»ï¼‰</span>
        <button class="btn blue small" id="buy1">+1 â›ï¸ (-120pt)</button>
        <button class="btn blue small" id="buy10">+10 â›ï¸ (-1200pt)</button>
        <button class="btn blue small" id="buyMax">MAXã¾ã§</button>
      </div>
    </div>

    <div class="panel">
      <div class="row" style="gap:10px;">
        <div style="display:flex; flex-direction:column; gap:8px; flex:1;">
          <div>
            <div class="label">ãƒ”ãƒƒã‚±ãƒ«å›å¾©é€Ÿåº¦ã‚¢ãƒƒãƒ— Lv.<span id="uRegenLv">0</span>ï¼ˆæœ€çŸ­1sï¼‰</div>
            <button class="btn accent small" id="uRegenBtn">è³¼å…¥: <span id="uRegenCost">500</span>pt</button>
          </div>
          <div>
            <div class="label">ãƒ”ãƒƒã‚±ãƒ«æœ€å¤§å€‹æ•°ã‚¢ãƒƒãƒ— Lv.<span id="uMaxLv">0</span>ï¼ˆä¸Šé™100ï¼‰</div>
            <button class="btn accent small" id="uMaxBtn">è³¼å…¥: <span id="uMaxCost">800</span>pt</button>
          </div>
        </div>
        <div style="display:flex; flex-direction:column; gap:8px; flex:1;">
          <div>
            <div class="label">ãƒã‚¤ãƒ³ãƒˆã‚¢ãƒƒãƒ— Lv.<span id="uPointLv">0</span>ï¼ˆ+10%/Lvï¼‰</div>
            <button class="btn accent small" id="uPointBtn">è³¼å…¥: <span id="uPointCost">700</span>pt</button>
          </div>
          <div>
            <div class="label">é‰±çªŸæ¡å–å€‹æ•°ã‚¢ãƒƒãƒ— Lv.<span id="uCaveLv">0</span>ï¼ˆ+1å€‹/Lvï¼‰</div>
            <button class="btn accent small" id="uCaveBtn">è³¼å…¥: <span id="uCaveCost">600</span>pt</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer></footer>
</div>

<div id="toast" class="toast"></div>

<script>
(() => {
  // Game constants
  const COLS = 6, ROWS = 7;
  const DIRT = 'dirt', STONE = 'stone', CAVE = 'cave', EMPTY='empty';
  const DIRT_PT = 100, STONE_PT = 200;
  const DIRT_COST = 1, STONE_COST = 2;
  const PICK_PRICE = 120; // pt per pick
  const MAX_PICK_CAP = 100;
  const REGEN_BASE_SEC = 5; // +1 pick per X sec baseline
  const REGEN_MIN_SEC = 1;
  const CAVE_TIMES = { small: 30_000, medium: 60_000, large: 120_000 }; // ms
  const CAVE_SIZES = { small:1, medium:2, large:3 };
  const CAVE_WEIGHTS = [ ['small', 0.6], ['medium', 0.3], ['large',0.1] ];
  const CAVE_SPAWN_CHANCE = 0.12; // per new row attempt
  const SAVE_KEY = 'mini-mine-v1';

  // State
  const state = {
    grid: [], // [row][col] -> cell object
    depth: 0,
    score: 0,
    picks: 50,
    picksMax: 100,
    upgrades: {
      regen: 0, // faster regen
      max: 0,   // increases max picks (up to 100)
      point: 0, // +10% per level
      cave: 0   // +1 loot per level
    },
    caves: {}, // caveId -> {sizeName, size, cells:[{r,c}], startedAt, totalMs, progressMs, done}
    regen: { accMs: 0 },
  };

  // Upgrade costs (scaling)
  const costBase = { regen: 500, max: 800, point: 700, cave: 600 };
  const costGrowth = 1.6;

  // DOM
  const el = {
    grid: document.getElementById('grid'),
    score: document.getElementById('score'),
    depth: document.getElementById('depth'),
    picks: document.getElementById('picks'),
    picksMax: document.getElementById('picksMax'),
    regenLabel: document.getElementById('regenLabel'),
    regenBar: document.getElementById('regenBar'),
    toast: document.getElementById('toast'),
    buy1: document.getElementById('buy1'),
    buy10: document.getElementById('buy10'),
    buyMax: document.getElementById('buyMax'),
    uRegenBtn: document.getElementById('uRegenBtn'),
    uMaxBtn: document.getElementById('uMaxBtn'),
    uPointBtn: document.getElementById('uPointBtn'),
    uCaveBtn: document.getElementById('uCaveBtn'),
    uRegenLv: document.getElementById('uRegenLv'),
    uMaxLv: document.getElementById('uMaxLv'),
    uPointLv: document.getElementById('uPointLv'),
    uCaveLv: document.getElementById('uCaveLv'),
    uRegenCost: document.getElementById('uRegenCost'),
    uMaxCost: document.getElementById('uMaxCost'),
    uPointCost: document.getElementById('uPointCost'),
    uCaveCost: document.getElementById('uCaveCost'),
  };

  function rand(){ return Math.random(); }
  function choiceWeighted(entries){
    const total = entries.reduce((s, [,w]) => s+w, 0);
    let r = rand()*total;
    for(const [k,w] of entries){ if((r-=w) <= 0) return k; }
    return entries[0][0];
  }

  function pointMultiplier(){
    return 1 + 0.10 * state.upgrades.point;
  }

  function regenIntervalMs(){
    const factor = Math.pow(0.9, state.upgrades.regen);
    const sec = Math.max(REGEN_MIN_SEC, REGEN_BASE_SEC * factor);
    return sec*1000;
  }

  function nextUpgradeCost(key){
    const lv = state.upgrades[key];
    return Math.floor(costBase[key] * Math.pow(costGrowth, lv));
  }

  function newCell(type, caveId=null){
    return { type, caveId }; // type: 'dirt'|'stone'|'cave'
  }

  function initGrid(){
    state.grid = [];
    for(let r=0;r<ROWS;r++){
      state.grid[r] = genRow();
    }
  }

  function genRow(){
    // Create a base row (dirt/stone)
    const row = new Array(COLS).fill(0).map(() => {
      const isStone = Math.random() < 0.35; // 35% stone baseline
      return newCell(isStone ? STONE : DIRT);
    });

    // Maybe spawn cave cluster
    if(Math.random() < CAVE_SPAWN_CHANCE){
      const sizeName = choiceWeighted(CAVE_WEIGHTS);
      const size = CAVE_SIZES[sizeName];
      // Try to place within the new row and possibly above rows if size > 1
      // Cave top-left row will be current "bottom-1" (since this row is at bottom index ROWS-1).
      // To keep it simple, only spawn caves that fully fit within bottom 3 rows window.
      const maxTop = ROWS-1; // we'll stamp across rows [top ... top+size-1], must be < ROWS
      const top = Math.max(0, (ROWS-1) - (size-1));
      const left = Math.floor(Math.random() * (COLS - size + 1));

      const caveId = 'cv_' + Math.random().toString(36).slice(2,9);
      const cells = [];
      // Ensure we have rows up to top+size-1
      for(let rr=0; rr<ROWS; rr++){
        if(!state.grid[rr]) state.grid[rr] = new Array(COLS).fill(0).map(() => newCell(DIRT));
      }
      for(let dr=0; dr<size; dr++){
        const r = top + dr;
        for(let dc=0; dc<size; dc++){
          const c = left + dc;
          state.grid[r][c] = newCell(CAVE, caveId);
          cells.push({r, c});
        }
      }
      state.caves[caveId] = { sizeName, size, cells, startedAt:null, totalMs: CAVE_TIMES[sizeName], progressMs:0, done:false };
    }
    return row;
  }

  function shiftDownOneMeter(){
    // Remove the top row, push a new row at the bottom
    state.grid.shift();
    state.grid.push(genRow());
    state.depth += 1;
    renderHUD();
    renderGrid();
  }

  function addScore(pts){
    const mult = pointMultiplier();
    state.score += Math.floor(pts * mult);
    renderHUD();
  }

  function spendScore(pts){
    if(state.score < pts) return false;
    state.score -= pts;
    renderHUD();
    return true;
  }

  function addPicks(n){
    state.picks = Math.min(state.picks + n, state.picksMax);
    renderHUD();
  }

  function spendPicks(n){
    if(state.picks < n) return false;
    state.picks -= n;
    renderHUD();
    return true;
  }

  function mineCell(r,c, targetEl, pageX, pageY){
    const cell = state.grid[r][c];
    if(!cell) return;

    if(cell.type === CAVE){
      handleCaveTap(cell.caveId, r, c);
      return;
    }

    if(cell.type === DIRT){
      if(!spendPicks(DIRT_COST)){ toast('â›ï¸ä¸è¶³'); return; }
      addScore(DIRT_PT);
      animatePick(targetEl, pageX, pageY);
      state.grid[r][c] = newCell(EMPTY);
    }else if(cell.type === STONE){
      if(!spendPicks(STONE_COST)){ toast('â›ï¸ä¸è¶³ï¼ˆçŸ³ã¯2å€‹ï¼‰'); return; }
      addScore(STONE_PT);
      animatePick(targetEl, pageX, pageY);
      state.grid[r][c] = newCell(EMPTY);
    }else if(cell.type === EMPTY){
      toast('ãã“ã¯ç©ºã ã‚ˆ');
      return;
    }

    // If mined in bottom row, go 1m deeper immediately
    if(r === ROWS-1){
      shiftDownOneMeter();
    }else{
      // Just re-render the single cell
      renderCell(r,c);
    }

    save();
  }

  function handleCaveTap(caveId, r, c){
    const cave = state.caves[caveId];
    if(!cave || cave.done) return;
    if(!cave.startedAt){
      cave.startedAt = performance.now();
      toast(`é‰±çªŸæ¢ç´¢é–‹å§‹ï¼ˆ${cave.sizeName}ï¼‰`);
      renderGrid(); // draws timer bars
    }else{
      // show remaining
      const remaining = Math.max(0, cave.totalMs - cave.progressMs);
      toast(`æ¢ç´¢ä¸­â€¦ æ®‹ã‚Š ${Math.ceil(remaining/1000)}s`);
    }
  }

  function completeCave(caveId){
    const cave = state.caves[caveId];
    if(!cave || cave.done) return;
    cave.done = true;

    // Loot calculation: base 120pt per tile Ã— tiles Ã— (1 + caveLv)
    const tiles = cave.size * cave.size;
    const lootCount = tiles * (1 + state.upgrades.cave);
    const lootPt = 120 * lootCount;
    addScore(lootPt);

    // Clear cave cells to empty
    cave.cells.forEach(({r,c}) => { if(state.grid[r]?.[c]?.caveId === caveId){ state.grid[r][c] = newCell(EMPTY); } });
    toast(`é‰±çªŸæ¢ç´¢å®Œäº†ï¼ +${Math.floor(lootPt * pointMultiplier())}pt`);
    renderGrid();
    save();
  }

  function updateCaves(dt){
    for(const [id, cave] of Object.entries(state.caves)){
      if(!cave.startedAt || cave.done) continue;
      cave.progressMs = Math.min(cave.totalMs, cave.progressMs + dt);
      if(cave.progressMs >= cave.totalMs){
        completeCave(id);
      }
    }
  }

  // Rendering
  function renderHUD(){
    el.score.textContent = state.score;
    el.depth.textContent = state.depth;
    el.picks.textContent = state.picks;
    el.picksMax.textContent = state.picksMax;

    // Regen label
    const interval = regenIntervalMs()/1000;
    el.regenLabel.textContent = `+1 / ${interval.toFixed(2).replace(/\.00$/,'')}s`;

    // Upgrades text & costs
    el.uRegenLv.textContent = state.upgrades.regen;
    el.uMaxLv.textContent = state.upgrades.max;
    el.uPointLv.textContent = state.upgrades.point;
    el.uCaveLv.textContent = state.upgrades.cave;
    el.uRegenCost.textContent = nextUpgradeCost('regen');
    el.uMaxCost.textContent = nextUpgradeCost('max');
    el.uPointCost.textContent = nextUpgradeCost('point');
    el.uCaveCost.textContent = nextUpgradeCost('cave');

    // Disable max upgrade if at cap
    el.uMaxBtn.disabled = state.picksMax >= MAX_PICK_CAP && state.upgrades.max >= 0; // keep purchasable until reaches cap
    // Buy buttons disable if already at cap and full
    const canBuyAny = state.picks < state.picksMax && state.score >= PICK_PRICE;
    el.buy1.disabled = !(state.score >= PICK_PRICE && state.picks < state.picksMax);
    el.buy10.disabled = !(state.score >= PICK_PRICE*10 && state.picks < state.picksMax);
    el.buyMax.disabled = !canBuyAny;
  }

  function cellTextureStyle(cell){
    if(cell.type === DIRT) return 'background-image:url(dirt.png)';
    if(cell.type === STONE) return 'background-image:url(stone.png)';
    if(cell.type === CAVE) return 'background-image:url(cave.png)';
    if(cell.type === EMPTY) return 'background:linear-gradient(180deg,#091119,#0a1017)';
    return '';
  }

  function renderGrid(){
    // Build DOM once, update in place
    const frag = document.createDocumentFragment();
    el.grid.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = state.grid[r][c];
        const div = document.createElement('div');
        div.className = 'cell';
        div.dataset.r = r; div.dataset.c = c;

        const tex = document.createElement('div');
        tex.className = 'tex';
        tex.style = cellTextureStyle(cell);
        div.appendChild(tex);

        if(cell.type === CAVE){
          const cave = state.caves[cell.caveId];
          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = cave.sizeName === 'small' ? 'S' : (cave.sizeName === 'medium' ? 'M' : 'L');
          div.appendChild(badge);

          const bar = document.createElement('div');
          bar.className = 'cave-timer';
          const i = document.createElement('i');
          i.style.width = cave.startedAt ? (100 * cave.progressMs / cave.totalMs) + '%' : '0%';
          bar.appendChild(i);
          div.appendChild(bar);
        }

        div.addEventListener('click', (e) => {
          const rect = e.currentTarget.getBoundingClientRect();
          mineCell(r,c, e.currentTarget, rect.left + rect.width/2, rect.top + rect.height/2);
        }, {passive:true});

        frag.appendChild(div);
      }
    }
    el.grid.appendChild(frag);
  }

  function renderCell(r,c){
    const idx = r*COLS + c;
    const cellEl = el.grid.children[idx];
    if(!cellEl) return;
    const cell = state.grid[r][c];
    const tex = cellEl.querySelector('.tex');
    if(tex) tex.style = cellTextureStyle(cell);
    // Clear/add cave UI
    cellEl.querySelectorAll('.badge, .cave-timer').forEach(n => n.remove());
    if(cell.type === CAVE){
      const cave = state.caves[cell.caveId];
      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = cave.sizeName === 'small' ? 'S' : (cave.sizeName === 'medium' ? 'M' : 'L');
      const bar = document.createElement('div');
      bar.className = 'cave-timer';
      const i = document.createElement('i');
      i.style.width = cave.startedAt ? (100 * cave.progressMs / cave.totalMs) + '%' : '0%';
      bar.appendChild(i);
      cellEl.appendChild(badge);
      cellEl.appendChild(bar);
    }
  }

  function animatePick(targetEl, pageX, pageY){
    const pick = document.createElement('div');
    pick.className = 'pick-anim';
    pick.textContent = 'â›ï¸';
    const rect = targetEl.getBoundingClientRect();
    const x = rect.left + rect.width/2;
    const y = rect.top + rect.height/2;
    pick.style.left = x + 'px';
    pick.style.top = y + 'px';
    pick.style.position = 'fixed';
    document.body.appendChild(pick);
    setTimeout(()=> pick.remove(), 420);
  }

  function toast(msg){
    const t = el.toast;
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(t._to);
    t._to = setTimeout(() => t.classList.remove('show'), 1300);
  }

  // Regen loop
  let last = performance.now();
  function tick(now){
    const dt = now - last; last = now;

    // Regen
    state.regen.accMs += dt;
    const interval = regenIntervalMs();
    const progress = Math.min(1, state.regen.accMs / interval);
    el.regenBar.style.width = (progress*100) + '%';
    if(state.regen.accMs >= interval){
      state.regen.accMs -= interval;
      if(state.picks < state.picksMax){
        state.picks++;
        renderHUD();
      }
    }

    // Caves
    updateCaves(dt);
    // Update cave bars in DOM
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = state.grid[r][c];
        if(cell.type === CAVE){
          const idx = r*COLS + c;
          const node = el.grid.children[idx];
          const cave = state.caves[cell.caveId];
          const bar = node?.querySelector('.cave-timer > i');
          if(bar) bar.style.width = cave.startedAt ? (100 * cave.progressMs / cave.totalMs) + '%' : '0%';
        }
      }
    }

    requestAnimationFrame(tick);
  }

  // Upgrade handlers
  function buyUpgrade(key){
    const cost = nextUpgradeCost(key);
    if(state.score < cost){ toast('ãƒã‚¤ãƒ³ãƒˆä¸è¶³'); return; }

    if(key === 'max'){
      // +10 max per lv, clamp to 100
      if(state.picksMax >= MAX_PICK_CAP){ toast('æœ€å¤§ã¯100'); return; }
      if(!spendScore(cost)) return;
      state.upgrades.max++;
      state.picksMax = Math.min(MAX_PICK_CAP, 50 + state.upgrades.max*10);
      // If picks > new max (shouldnâ€™t happen), clamp
      if(state.picks > state.picksMax) state.picks = state.picksMax;
      toast('ãƒ”ãƒƒã‚±ãƒ«æœ€å¤§ã‚¢ãƒƒãƒ—ï¼');
    }else if(key === 'regen'){
      if(!spendScore(cost)) return;
      state.upgrades.regen++;
      // reset bar to feel snappier
      state.regen.accMs = 0;
      toast('å›å¾©é€Ÿåº¦ã‚¢ãƒƒãƒ—ï¼');
    }else if(key === 'point'){
      if(!spendScore(cost)) return;
      state.upgrades.point++;
      toast('ãƒã‚¤ãƒ³ãƒˆå€ç‡ã‚¢ãƒƒãƒ—ï¼');
    }else if(key === 'cave'){
      if(!spendScore(cost)) return;
      state.upgrades.cave++;
      toast('é‰±çªŸæ¡å–å€‹æ•°ã‚¢ãƒƒãƒ—ï¼');
    }
    renderHUD(); save();
  }

  // Buy picks
  function buyPicks(n){
    n = Math.max(1, n|0);
    const room = state.picksMax - state.picks;
    if(room <= 0){ toast('ã‚‚ã†MAX'); return; }
    const buy = Math.min(room, n);
    const cost = buy * PICK_PRICE;
    if(state.score < cost){ toast('ãƒã‚¤ãƒ³ãƒˆä¸è¶³'); return; }
    spendScore(cost);
    addPicks(buy);
    toast(`â›ï¸ +${buy}`);
    save();
  }

  // Save/Load
  function save(){
    const data = JSON.stringify(state, (k,v) => {
      if(k === 'toast' || k === 'gridEl') return undefined;
      return v;
    });
    try{ localStorage.setItem(SAVE_KEY, data); }catch(e){}
  }
  function load(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const s = JSON.parse(raw);
      // Minimal validation & migrate
      Object.assign(state, s);
      // Rebuild caves map if missing methods (no methods anyway)
      return true;
    }catch(e){ return false; }
  }

  // Events
  el.buy1.addEventListener('click', () => buyPicks(1));
  el.buy10.addEventListener('click', () => buyPicks(10));
  el.buyMax.addEventListener('click', () => buyPicks(999));
  el.uRegenBtn.addEventListener('click', () => buyUpgrade('regen'));
  el.uMaxBtn.addEventListener('click', () => buyUpgrade('max'));
  el.uPointBtn.addEventListener('click', () => buyUpgrade('point'));
  el.uCaveBtn.addEventListener('click', () => buyUpgrade('cave'));

  // Bootstrap
  if(!load()){
    initGrid();
    state.depth = 0;
    state.score = 0;
    state.picks = 50;
    state.picksMax = 100;
  }
  renderHUD();
  renderGrid();
  requestAnimationFrame((t)=>{ last = t; requestAnimationFrame(tick); });

  // UX: prevent long-press menu
  window.addEventListener('contextmenu', e => e.preventDefault());
})();
</script>
</body>
</html>
